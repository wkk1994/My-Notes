# 图的表示

图（Graph）经常用来存储微博、微信等这些社交网络的好友关系，涉及图的算法很多，也非常复杂，比如图的搜索、最短路径、最小生成树、二分图等等。

## 如何理解“图”

图（Graph）也是一种非线性表结构，和树相比，更加复杂。常见的图有向图、无向图、带权图。

### **无向图**

树中的元素称为节点，图中的元素称为定点（vertex）。图中的一个点点可以与任意其他顶点建立连接关系，这种建立的关系叫做边（edge）。一个顶点相连接的边的条数称为这个顶点的度（degree）。

![无向图示例](https://static001.geekbang.org/resource/image/df/af/df85dc345a9726cab0338e68982fd1af.jpg)

生活中有很多符合图这种结构的例子。比如，上面的社交网络，就是一个非常典型的图结构。拿微信举例：每个用户就是图的一个顶点，如果两个用户之间互加好友，那就在两个顶点之间建立一条边。所以整个微信的好友关系就可以用一张图来表示。其中，每个用户有多少个好友，对应图中，就是顶点的度（degree）。

### **有向图**

上面图中的边是没有方向的，如果加上方向就是有向图。

![有向图示例](https://static001.geekbang.org/resource/image/c3/96/c31759a37d8a8719841f347bd479b796.jpg)

无向图中的度表示一个顶点有多少边。在有向图中，度分为入度（In-degree）和出度（Out-degree）。

顶点的入度，表示有多少条边指向这个顶点；顶点的出度，表示有多少条边是以这个顶点为起点执行其他顶点。对应到微博的例子，入度就表示有多少粉丝，出度就表示关注了多少人。

### **带权图（weighted graph）**

在QQ社交关系中，存在QQ亲密度的功能。QQ 不仅记录了用户之间的好友关系，还记录了两个用户之间的亲密度，如果两个用户经常往来，那亲密度就比较高；如果不经常往来，亲密度就比较低。这时候就需要另外一种带权图（weighted graph）来记录这种好友关系。

在带权图中，每条边都有一个权重（weight），可以通过这个权重来表示QQ好友间的亲密度。

![带权图示例](https://static001.geekbang.org/resource/image/55/e8/55d7e4806dc47950ae098d959b03ace8.jpg)

## 如何在内存中存储图

### 邻接矩阵存储方法

图最直观的存储方式就是，邻接矩阵（Adjacency Matrix）。

邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点i与顶点j之间有边，就将A[i][j]和A[j][i]标记为1；对于有向图来说，如果顶点i到顶点j之间，有一条箭头从顶点i指向顶点j的边，就将A[i][j]标记为1。同理，如果有一条箭头从顶点j指向顶点i的边，就将A[j][i]标记为1。对于带权图，数组中存储相应的权重。

![邻接矩阵存储示例](https://static001.geekbang.org/resource/image/62/d2/625e7493b5470e774b5aa91fb4fdb9d2.jpg)

**邻接矩阵来表示一个图，虽然简单、直观，但是毕竟浪费存储空间。**

对于无向图来说，如果 A[i][j]等于 1，那 A[j][i]也肯定等于 1。实际上，只需要存储一个就可以了。也就是说，无向图的二维数组中，如果将其用对角线划分为上下两部分，那只需要利用上面或者下面这样一半的空间就足够了，另外一半白白浪费掉了。

如果存储的是稀疏图（Sparse Matrix），也就是说顶点很多，但是每个顶点的边并不多，那邻接矩阵的存储方法就更加浪费空间了。比如微信有好几亿的用户，对应到图上就是好几亿的顶点。但是每个用户的好友并不会很多，一般也就三五百个而已。如果使用邻接矩阵来存储，那绝大部分的存储空间都被浪费了。

邻接矩阵的存储方法的优点：邻接矩阵的存储方式简单、直接，因为基于数组，所以在获取两个顶点的关系时，就非常高效。其次，用邻接矩阵存储图的另外一个好处是方便计算。这是因为，用邻接矩阵的方式存储图，可以将很多图的运算转换成矩阵之间的运算。比如求解最短路径问题时会提到一个Floyd-Warshall 算法，就是利用矩阵循环相乘若干次得到结果。

### 邻接表（Adjacency List）存储方法

邻接表的存储方式是，将每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。

下图中画的是一个有向图的邻接表存储方式，每个顶点对应的链表里面，存储的是指向的顶点。对于无向图来说，也是类似的，不过，每个顶点的链表中存储的，是跟这个顶点有边相连的顶点。

![邻接表存储方式示例](https://static001.geekbang.org/resource/image/03/94/039bc254b97bd11670cdc4bf2a8e1394.jpg)

邻接矩阵存储起来比较浪费空间，但是使用起来比较节省时间。相反，邻接表存储起来比较节省空间，但是使用起来就比较耗时间。比如上图中的例子，如果要确定顶点2到顶点4是否存在边，需要遍历顶点2对应的链表，看链表中是否存在顶点4。而且，链表的存储方式对缓存不友好，所以，比起邻接矩阵的存储方式，在邻接表中查询两个顶点之间的关系就没有那么高效了。

因为邻接表和散列很相似，所以在实际开发中，可以选择用红黑树取代链表，这样可以加速查找两个顶点之间是否存在边了。

## 如何存储微博、微信等社交网络中的好友关系？

微博、微信是两种图，前者是有向图，后者是无向图。这个问题上，两者的解决思路差不多，所以只使用微博来解读。

针对微博用户关系，假设需要支持下面的几种操作：

* 判断用户A是否关注了用户B；
* 判断用户A是否被用户B关注；
* 用户A关注用户B；
* 用户A取消关注用户B；
* 根据用户名称的首字母排序，分页获取用户的粉丝列表；
* 根据用户名称的首字符排序，分页获取用户的关注列表；

因为社交网络是一种稀疏图，所以适合使用邻接表存储。不过用一个邻接表来存储这种有向图是不够的。因为要查询某个用户关注列表非常容易，但是要查询某个用户的粉丝比较困难，所以需要一个逆邻接表。邻接表中存储了用户的关注关系，逆邻接表中存储了用户的被关注关系。这样，如果要查找某个用户关注了哪些用户，可以在邻接表中查找；如果要查找某个用户被哪些用户关注了，从逆邻接表中查找。

![微博用户关系图存储示例](https://static001.geekbang.org/resource/image/50/a1/501440bcffdcf4e6f9a5ca1117e990a1.jpg)

又因为基础的邻接表不适合快速的判断两个用户之间是否关注与被关注的关系，所以需要将邻接表中的链表改为支持快速查找的动态数据结构。可选择的有红黑树、跳表、有序动态数组和散列表。因为需要按照用户名称的首字符排序，分页来获取用户的粉丝列表或关注列表，所以选择使用跳表。这是因为，跳表插入、删除、查找都非常高效，时间复杂度是 O(logn)，空间复杂度上稍高，是 O(n)。最重要的一点，跳表中存储的数据本来就是有序的了，分页获取粉丝列表或关注列表，就非常高效。

如果对于小规模的数据，比如社交网络中只有几万、几十万个用户，我们可以将整个社交关系存储在内存中，上面的解决思路是没有问题的。但是如果像微博那样有上亿的用户，数据规模太大，我们就无法全部存储在内存中了。

这时候，我们可以通过哈希算法等数据分片方式，将邻接表存储在不同的机器上。你可以看下面这幅图，我们在机器 1 上存储顶点 1，2，3 的邻接表，在机器 2 上，存储顶点 4，5 的邻接表。逆邻接表的处理方式也一样。当要查询顶点与顶点关系的时候，我们就利用同样的哈希算法，先定位顶点所在的机器，然后再在相应的机器上查找。

![邻接表分机器存储示例](https://static001.geekbang.org/resource/image/08/2f/08e4f4330a1d88e9fec94b0f2d1bbe2f.jpg)

除此之外，我们还有另外一种解决思路，就是利用外部存储（比如硬盘），因为外部存储的存储空间要比内存会宽裕很多。数据库是我们经常用来持久化存储关系数据的，所以我这里介绍一种数据库的存储方式。我用下面这张表来存储这样一个图。为了高效地支持前面定义的操作，我们可以在表上建立多个索引，比如第一列、第二列，给这两列都建立索引。

![外部存储-数据库存储表结构示例](https://static001.geekbang.org/resource/image/73/8f/7339595c631660dc87559bec2ddf928f.jpg)
