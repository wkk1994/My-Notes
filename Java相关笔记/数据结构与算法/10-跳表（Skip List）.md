# 跳表（Skip List）

## 跳表的定义

跳表是在链表的基础上改造而来，通过在跳表上添加多级索引加快检索速度。跳表是一个各方面性能都比较优秀的动态数据结构，可以支持快速地插入、删除、查找操作，而且实现起来并不复杂，效率可以媲美红黑树（Red-black tree）。

## 如何理解跳表

在二分查找中，通过折半查找的方式快速可以定位要查找的元素，跳表也是借鉴了这种思想，通过在原链表上添加多级索引层，再通过索引层中数据指向原链表数据加速查找过程。

![2层索引层的链表](https://static001.geekbang.org/resource/image/49/65/492206afe5e2fef9f683c7cff83afa65.jpg)

如图为有2层索引层的链表，这样要查找为16的元素，只需要先在1～13～直接查找一次，再在13～17查找一次，最后从13顺序查找到16元素。这样累计下来一共查找了6次。

## 跳表的时间复杂度分析

一个单链表查询某个数据的时间复杂度是O(N)，对于一个有多级索引的的跳表中，查询的复杂度是多少？

按照每两个节点向上抽取一个上级索引的节点，那一级节点大约是N/2，二级节点是N/4，以此类推k级索引的节点个数是$N/(2^k)$。假设最高索引有2个节点，那么$N/(2^k)$ = 2，k = $logN-1$，在每一层索引需要遍历最多只需要3个节点（由图中就可以推导出），所以在跳表中查询一个数据的时间复杂度就是 O($3logN$)，去掉常数就是O($logN$)。

## 跳表的空间复杂度分析

跳表通过多层索引加快数据检索，也是一种空间换时间的设计思路。相比于单纯的单链表，跳表需要存储多级索引，肯定要消耗更多的存储空间。

**跳表的空间复杂度分析：**

假设原始链表的大小为N，那一层索引大约有N/2个节点，二层索引有N/4个节点，以此类推就是一个等比数列。索引的结点总和就是 n/2+n/4+n/8…+8+4+2=n-2。所以，跳表的空间复杂度是 O(n)。

怎么优化低索引占用的内存空间？如果我们每三个结点或五个结点，抽一个结点到上级索引，是不是就不用那么多索引结点了呢？假设3个节点向上抽取一个索引节点，那么总的索引结点大约就是 n/3+n/9+n/27+…+9+3+1=n/2。尽管空间复杂度还是 O(n)，但比上面的每两个结点抽一个结点的索引构建方法，要减少了一半的索引结点存储空间。

实际上，在软件开发中，不需要太在意索引占用的内存空间。因为在实际软件开发中，原始链表中存储的有可能是很大的对象，而索引节点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引节点大很多时，那索引占用的额外空间就可以忽略了。

## 跳表的动态插入和删除

跳表还支持动态插入、删除操作，而且插入、删除操作的时间复杂度是O(logN)。

**插入的时间复杂度分析：**

在单链表中，确定好插入位置后，插入节点的时间复杂度为O(1)。对于顺序单链表需要先确定插入位置，查找插入位置的时间复杂度也是O(logN)，所以插入的时间复杂度是O(logN)。

**删除操作的时间复杂度分析：**

如果删除的节点在多层索引中有出现，除了删除原始链表中的节点，还要删除索引中的。因为单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。所以在查找要删除的结点的时候，一定要获取前驱结点。当然，如果用的是双向链表，就不需要考虑这个问题了。

## 跳表索引动态更新

当不停地向跳表中插入数据时，如果不更新索引，可能出现某2个索引结点之间的数据非常多的情况。极端情况下，跳表还会退化成单链表。

跳表作为一种动态数据结构，需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中的节点增多了，索引的节点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。

红黑树、AVL 树这样平衡二叉树，是通过左右旋的方式保持左右子树的大小平衡。而跳表是通过随机函数来维护“平衡性”。

当跳表插入数据时，可以选择同时将这个数据插入到部分索引层中。通过一个随机函数，选择将数据插入到哪几级索引中，比如随机函数生成了值 K，那就将这个结点添加到第一级到第 K 级这 K 级索引中。

![随机函数插入示意图](https://static001.geekbang.org/resource/image/a8/a7/a861445d0b53fc842f38919365b004a7.jpg)

随机函数的选择很有讲究，从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化。

## 为什么 Redis 要用跳表来实现有序集合，而不是红黑树？

Redis中有序集合是通过跳表实现的，严格意义上还用到了散列表。Redis 中的有序集合支持的核心操作主要有下面这几个：

* 插入一个数据；
* 删除一个数据；
* 查找一个数据；
* 按照区间查找数据（比如查找值在[100, 356]之间的数据）；
* 迭代输出有序序列。

其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。对于按照区间查找数据这个操作，跳表可以做到 O(logN) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。

当然，Redis 之所以用跳表来实现有序集合，还有其他原因，比如，跳表更容易代码实现。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。还有，跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。

不过，跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的 Map 类型都是通过红黑树来实现的。我们做业务开发的时候，直接拿来用就可以了，不用费劲自己去实现一个红黑树，但是跳表并没有一个现成的实现，所以在开发中，如果你想使用跳表，必须要自己实现。