# 递归树：如何借助树来求解递归算法的时间复杂度

对于递归代码的时间复杂度计算，除了使用递推公式进行数学推导外，还可以借助递归树来分析算法的时间复杂度。利用递归树进行分析，在某些时候更方便快捷。

## 递归树与时间复杂度分析

递归的思想就是，将大问题分解为小问题来求解，然后再将小问题分解为小小问题。这样一层一层地分解，直到问题的数据规模分解的足够小，不用再继续递归分解为止。

如果把这个一层一层的分解过程画成图，它其实就是一棵树，这棵树称为递归树。

![递归树示例](https://static001.geekbang.org/resource/image/1d/a3/1d9648b7f43e430473d76d24803159a3.jpg)

## 分析归并排序的时间复杂度

归并排序的过程画成一颗递归树如下：

![归并排序递归树](https://static001.geekbang.org/resource/image/c6/d0/c66bfc3d02d3b7b8f64c208bf4c948d0.jpg)

每次分解都是一分为二，时间复杂度上记作常亮1。在归并排序中最耗时的操作是归并操作，归并操作的时间复杂度和数据规模有关，时间记作n。

现在，只需要知道这棵树的高度h，用高度h乘以每一层的时间消耗n，就可以得到总的时间复杂度O(n * h)。又因为每次数据都是一分为二，所以h = log~2~n，所以，归并排序递归实现的时间复杂度就是 O(nlogn)。

## 分析快速排序的时间复杂度

快速排序在最好的情况下，每次分区都能一分为二，这个时候用递推公式T(n) = 2T(n/2) + n，很容易就推导出时间复杂度是O(nlogn)。但是，对不不能巧好一分为二的情况，时间复杂度就不好分析了。

假设平均情况下，每次分区之后，两个分区的大小比例为1:k，当k=9时，如果用递推公示的方法来求解时间复杂度，递推公式就写成T(n)=T(n/10​)+T(9n/10​)+n。这个公式可以推导出时间复杂度，但是推导过程非常复杂。如果使用递归树来分析，画成的递归树可以是下面：

![快速排序递归树](https://static001.geekbang.org/resource/image/44/43/44972a3531dae0b7a0ccc935bc13f243.jpg)

每一层的操作的时间复杂度之和都为n，所以只要求出递归树的高度h，就可以知道快速排序的时间复杂度为O(h * n)。

快速排序的结束条件就是待排序的小区间大小为1，也就是说叶子节点的数据规模是1。从根节点n到叶子节点1，递归树中最短的一个路径是每次都乘以1/10，最长的一个路径是每次都乘以9/10。通过计算，可以得到，从根节点到叶子节点的最短路径是 log~10​~n，最长的路径是 log~10/9~​​n。

所以，遍历数据的个数总和就介于 nlog~10~​n 和 nlog910​​n 之间。根据复杂度的大 O 表示法，对数复杂度的底数不管是多少，我们统一写成 logn，所以，当分区大小比例是 1:9 时，快速排序的时间复杂度仍然是 O(nlogn)。也就是说，对于 k 等于 9，99，甚至是 999，9999……，只要 k 的值不随 n 变化，是一个事先确定的常量，那快排的时间复杂度就是 O(nlogn)。所以，从概率论的角度来说，快排的平均时间复杂度就是 O(nlogn)。

## 分析斐波那契数列的时间复杂度

斐波那契数列的代码示例：

```java
int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  return f(n-1) + f(n-2);
}
```

对这样一段代码的时间复杂度分析，通过递归树分析，画成递归树如下：

![斐波那契数列递归树](https://static001.geekbang.org/resource/image/9c/ce/9ccbce1a70c7e2def52701dcf176a4ce.jpg)

f(n) 分解为 f(n−1) 和 f(n−2)，每次数据规模都是 −1 或者 −2，叶子节点的数据规模是 1 或者 2。所以，从根节点走到叶子节点，每条路径是长短不一的。如果每次都是 −1，那最长路径大约就是 n；如果每次都是 −2，那最短路径大约就是 n/2​。每次分解之后的合并操作只需要一次加法运算，把加法运算的时间消耗记作1，所以，从上向下，第一层的总时间消耗是1，第二层是2，第三层是2^2^，依次类推第k层总的时间消耗为2^k^，那整个算法的总的时间消耗就是每一层时间消耗之和。

如果路径长度都为 n，那这个总和就是 2^n^−1。

```text
1+2+4+...+2^n-1^ = 2^n^-1
```

如果路径长度都是 2n​ ，那整个算法的总的时间消耗就是 2^n/2^​−1。

```text
1+2+4+...+2^n/2-1^ = 2^n/2^-1
```

所以，这个算法的时间复杂度就介于 O(2n) 和 O(22n​) 之间。虽然这样得到的结果还不够精确，只是一个范围，但是我们也基本上知道了上面算法的时间复杂度是指数级的，非常高。

## 分析全排列的时间复杂度

何编程打印一组数据的所有排列呢？这里就可以用递归来实现。

确定了最后一位数据，那就变成了求解剩下 n−1 个数据的排列问题。而最后一位数据可以是 n 个数据中的任意一个，因此它的取值就有 n 种情况。所以，“n 个数据的排列”问题，就可以分解成 n 个“n−1 个数据的排列”的子问题。

写成递推公式如下：

```text
假设数组中存储的是1，2， 3...n。

f(1,2,...n) = {最后一位是1, f(n-1)} + {最后一位是2, f(n-1)} +...+{最后一位是n, f(n-1)}。
```

代码示例：

```java

// 调用方式：
// int[]a = a={1, 2, 3, 4}; printPermutations(a, 4, 4);
// k表示要处理的子数组的数据个数
public void printPermutations(int[] data, int n, int k) {
  if (k == 1) {
    for (int i = 0; i < n; ++i) {
      System.out.print(data[i] + " ");
    }
    System.out.println();
  }

  for (int i = 0; i < k; ++i) {
    int tmp = data[i];
    data[i] = data[k-1];
    data[k-1] = tmp;

    printPermutations(data, n, k - 1);

    tmp = data[i];
    data[i] = data[k-1];
    data[k-1] = tmp;
  }
}
```

使用递归树分析这个递归的时间复杂度度，画出的递归树如下，并不是一个标准的二叉树：

![全排列的递归树](https://static001.geekbang.org/resource/image/82/9b/82f40bed489cf29b14192b44decf059b.jpg)

第一层分解有n次交换操作，第二层有n个节点，每个节点分解需要n-1次交换，所以第二层总的交换次数是 n∗(n−1)。第三层有 n∗(n−1) 个节点，每个节点分解需要 n−2 次交换，所以第三层总的交换次数是 n∗(n−1)∗(n−2)。以此类推，第 k 层总的交换次数就是 n∗(n−1)∗(n−2)∗…∗(n−k+1)。最后一层的交换次数就是 n∗(n−1)∗(n−2)∗…∗2∗1。每一层的交换次数之和就是总的交换次数。

```text
n + n*(n-1) + n*(n-1)*(n-2) +... + n*(n-1)*(n-2)*...*2*1
```

这个公式的求和比较复杂，只看最后一个数，n∗(n−1)∗(n−2)∗…∗2∗1 等于 n!，而前面的 n−1 个数都小于最后一个数，所以，总和肯定小于 n∗n!，也就是说，全排列的递归算法的时间复杂度大于 O(n!)，小于 O(n∗n!)，虽然我们没法知道非常精确的时间复杂度，但是这样一个范围已经让我们知道，全排列的时间复杂度是非常高的。

**有些代码比较适合用递推公式来分析，比如归并排序的时间复杂度、快速排序的最好情况时间复杂度；有些比较适合采用递归树来分析，比如快速排序的平均时间复杂度。而有些可能两个都不怎么适合使用，比如二叉树的递归前中后序遍历。**

## 问题

* 1 个细胞的生命周期是 3 小时，1 小时分裂一次。求 n 小时后，容器内有多少细胞？

  递推公式为f(n) = 2*f(n-1) - f(n-4)。