# 排序的优化

## 如何选择合适的排序算法

要实现一个通用、高效的排序函数，需要选择合适的排序算法。

![排序算法对比](https://static001.geekbang.org/resource/image/1f/fd/1f6ef7e0a5365d6e9d68f0ccc71755fd.jpg)

对于小规模的数据排序，可以选择时间复杂度是O($n^2$)的算法；如果对于大规模的数据排序，时间复杂度为O($nlogn$)的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。

在那么多时间复杂度为O(nlogn)的算法中，堆排序和快速排序都有比较多的应用，比如 Java 语言采用堆排序实现排序函数，C 语言使用快速排序实现排序函数。

## 如何优化快速排序

快速排序比较适合来实现排序函数，但是，快速排序在最坏情况下的时间复杂度是 O($n^2$)，如何来解决这个“复杂度恶化”的问题呢？

对于快速排序，当分区点选择的不够合理时，每次选择的数据都是最后一个数据时，时间复杂度就会退化为O($n^2$)。

**快速排序如何选择合适的分区点？**

最理想的分区点是：**被分区点分开的两个分区中，数据的数量差不多。**

两个比较常用、比较简单的分区算法：

* 1.三数取中法

  从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。

* 2.随机法

  随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选得很差的情况，所以平均情况下，这样选的分区点是比较好的。时间复杂度退化为最糟糕的 O(n2) 的情况，出现的可能性不大。

**快速排序的实现方式是使用递归，可能会导致堆栈溢出。** 可以通过限制堆栈的深度或者通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制。

## 举例分析排序函数

**Glibc 中的 qsort() 函数**

对于数据量小的数据，qsort() 会优先使用归并排序来排序输入数据；要排序的数据量比较大的时候，qsort() 会改为用快速排序算法来排序。qsort()的快速排序选择分区点的方式也是“三数取中法”，qsort() 是通过自己实现一个堆上的栈，手动模拟递归来解决的。

qsort() 并不仅仅用到了归并排序和快速排序，它还用到了插入排序。在快速排序的过程中，当要排序的区间中，元素的个数小于等于 4 时，qsort() 就退化为插入排序，不再继续用递归来做快速排序。因为，在小规模数据面前**O(n2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长**。

## 问题

* java中排序的实现方式？

jdk1.8中Arrays.sort(int[] a)实现方式：

a数组排序长度小于47，使用插入排序；大于47小于286用双轴快排；大于286用timsort归并排序，并在timesort中记录数据的连续的有序段的的位置，若有序段太多，也就是说数据近乎乱序，则用双轴快排，当然快排的递归调用的过程中，若排序的子数组数据数量小，用插入排序。
