# 字符串匹配基础

## 如何借助哈希算法实现高效字符串匹配

字符串匹配算法很多，比较简单的、好理解的有BF算法和RK算法。BF算法和RK算法都是单模式串匹配算法，也就是一个串跟一个串进行匹配。

主串和模式串的概念：在字符串A中查找字符串B，那么字符串A就是主串，字符串B就是模式串。

### BF算法

BF 算法中的 BF 是 Brute Force 的缩写，中文叫作暴力匹配算法，也叫朴素匹配算法。从名字可以看出，这种算法的字符串匹配方式很“暴力”，当然也就会比较简单、好懂，但相应的性能也不高。

把主串的长度记作n，模式串的长度记作m。因为是在主串中查找模式串，所以 n>m。BF算法的思想就是，在主串中，检查起始位置分别是0、1、2…n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的。

![BF算法图解](https://static001.geekbang.org/resource/image/f3/a2/f36fed972a5bdc75331d59c36eb15aa2.jpg)

BF算法的时间复杂度，在最坏情况下，每次都要比对m个字符，要比对n-m+1次，所以时间复杂度是O(n*m)。

尽管理论上，BF算法的时间复杂度很高，但是在实际开发中，它却是一个比较常见的字符串匹配算法。原因有两点：

* 第一，实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串中的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以停止了，不需要把m个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度是O(n*m)，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多。
* 第二，BF算法思想简单，代码实现也非常简单。简单意味着不容易出错，如果有bug也容易暴露和修复。在工程中，在满足性能要求的前提下，简单是首选。这也是常说的KISS设计原则。

所以，在实际的软件开发中，绝大部分情况下，BF算法就够用了。

### RK算法

RK算法的全称叫做Rabin-Karp算法，是由它的两位发明者Rabin和Karp名字来命名的。算是BF算法的升级版。

RK算法的思路是：通过哈希算法对主串中的n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。

**哈希算法的设计**

通过哈希算法计算子串的哈希值时，需要遍历子串中的每个字符，尽管模式串与子串比较的效率提高了，但是算法整体的效率并没有提高。这个时候就需要通过哈希算法的设计提高子串哈希值计算的效率了。

哈希设计的思路：假设要匹配的字符串的字符集中只包含K个字符，可以用一个K进制表示一个子串，这个K进制数转换成十进制数，作为子串的哈希值。

举例：比如要处理的字符串只包含a~z这26个小写字母，那么就用二十六进制来表示一个字符串。把a~z这26个字符映射到0~25这26个数字，a 就表示 0，b 就表示 1，以此类推，z 表示 25。

在十进制中，一个数字的值是通过下面的方式计算出来的，对应到二十六进制，一个包含a到z这26个字符的字符串，计算哈希值得时候，只需要吧进位从10改为26就可以了。

![26进制示例](https://static001.geekbang.org/resource/image/d5/04/d5c1cb11d9fc97d0b28513ba7495ab04.jpg)

这种哈希算法有一个特点，在主串中，相邻两个子串的哈希值得计算公式有一定关系。

![相邻子串表示示例](https://static001.geekbang.org/resource/image/f9/f5/f99c16f2f899d19935567102c59661f5.jpg)

可以看出，相邻两个子串s[i-1]和s[i]（i表示子串在主串中的起始位置，子串的长度都为m），对应的哈希值计算公式有交集，也就是说可以使用s[i-1]的哈希值很快计算出s[i]的哈希值。用公式表示如下：

```text
h[i-1]对应子串S[i-1, i+m-2]的哈希值为：
h[i-1] = 26^m-1 * (S[i-1] - a) + 26^m-2 * (S[i] - a) + ... + 26^0 * (S[i+m-2] - a);

h[i]对应子串S[i, i+m-1]的哈希值为：
h[i] = 26^m-1 * (S[i] - a) + ... + 26^1 * (S[i+m-2] - a) + 26^0 * (S(i+m-1 - a));

从公式可以看出，h[i]和h[i-1]的关系如下：

h[i] = (h[i-1] -26^m-1 * (S[i-1] - a)) * 26 + 26^0 * (S(i+m-1 - a));
```

不过，这里有一个小细节需要注意，那就是 26^(m-1) 这部分的计算，我们可以通过查表的方法来提高效率。我们事先计算好 26^0、26^1、26^2……26^(m-1)，并且存储在一个长度为 m 的数组中，公式中的“次方”就对应数组的下标。当我们需要计算 26 的 x 次方的时候，就可以从数组的下标为 x 的位置取值，直接使用，省去了计算的时间。

![数组获取次方示例图](https://static001.geekbang.org/resource/image/22/2f/224b899c6e82ec54594e2683acc4552f.jpg)

**RK 算法的时间复杂度分析**

整个Rk算法包含两部分，计算子串哈希值和模式串哈希值与子串哈希值之间进行比较。第一部分，可以通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值了。所以这部分的时间复杂度是O(n)。

模式串哈希值与每个子串哈希值之间的比较的时间复杂度是 O(1)，总共需要比较 n-m+1 个子串的哈希值，所以，这部分的时间复杂度也是 O(n)。所以，RK 算法整体的时间复杂度就是 O(n)。

这里还有一个问题就是，模式串很长，相应的主串中的子串也会很长，通过上面的哈希算法计算得到的哈希值就可能很大，如果超过了计算机中整型数据可以表示的范围，那该如何解决呢？

上面的哈希算法是没有散列冲突，也就是说一个字符串与二十六进制数一一对应，不同的字符串的哈希值肯定是不一样。因为是基于进制来表示一个字符串的，可以类比成十进制、十六进制来思考。假设字符串中只包含 a～z 这 26 个英文字母，那我们每个字母对应一个数字，比如 a 对应 1，b 对应 2，以此类推，z 对应 26。我们可以把字符串中每个字母对应的数字相加，最后得到的和作为哈希值。这种哈希算法产生的哈希值的数据范围就相对要小很多了。不过，这种哈希算法的哈希冲突概率也是挺高的。这只是举了一个最简单的设计方法，还有很多优化的方法，比如将每个字母从小到大对应一个素数，这样冲突的概率会降低一些。

之前只需要比较模式串和子串的哈希值是否相同，现在存在散列冲突时，当子串的哈希值和模式串的哈希值相等时，还要再对比一下子串和模式串本身。

所以，哈希算法的冲突概率要相对控制得低一些，如果存在大量冲突，就会导致 RK 算法的时间复杂度退化，效率下降。极端情况下，如果存在大量的冲突，每次都要再对比子串和模式串本身，那时间复杂度就会退化成 O(n*m)。但也不要太悲观，一般情况下，冲突不会很多，RK 算法的效率还是比 BF 算法高的。

## 总结

BF 算法是最简单、粗暴的字符串匹配算法，它的实现思路是，拿模式串与主串中是所有子串匹配，看是否有能匹配的子串。所以，时间复杂度也比较高，是 O(n*m)，n、m 表示主串和模式串的长度。不过，在实际的软件开发中，因为这种算法实现简单，对于处理小规模的字符串匹配很好用。

RK 算法是借助哈希算法对 BF 算法进行改造，即对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较的时间。所以，理想情况下，RK 算法的时间复杂度是 O(n)，跟 BF 算法相比，效率提高了很多。不过这样的效率取决于哈希算法的设计方法，如果存在冲突的情况下，时间复杂度可能会退化。极端情况下，哈希算法大量冲突，时间复杂度就退化为 O(n*m)。

## 问题

* 二维字符串匹配方法