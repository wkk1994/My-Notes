# 深度和广度优先搜索

## 什么是“搜索”算法

算法是作用于具体数据结构之上的，深度优先搜索算法和广度搜索算法都是基于“图”这种数据结构的。图这种数据结构的表达能力很强，大部分涉及搜索的场景都可以抽象成“图”。

图上的搜索算法，最直接的理解就是，在图中找出从一个顶点出发，到另一个顶点的路径。具体方法有很多，比如简单、最“暴力”的深度优先、广度优先搜索，还有A*、IDA*等启发式搜索算法。

## 广度优先搜索（BFS）

广度优先搜索（Breadth-First-Search），简称为BFS。它其实就是一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后次近的，依次往外搜索。

查找顶点s到顶点t的路径示例：

![广度优先搜索示例](https://static001.geekbang.org/resource/image/00/ea/002e9e54fb0d4dbf5462226d946fa1ea.jpg)

广度优先搜索的分解图：

![广度优先搜索的分解图1](https://static001.geekbang.org/resource/image/4f/3a/4fea8c4505b342cfaf8cb0a93a65503a.jpg)

![广度优先搜索的分解图2](https://static001.geekbang.org/resource/image/ea/23/ea00f376d445225a304de4531dd82723.jpg)

![广度优先搜索的分解图3](https://static001.geekbang.org/resource/image/4c/39/4cd192d4c220cc9ac8049fd3547dba39.jpg)

**广度优先搜索的时间、空间复杂度分析**

最坏情况下，终止顶点t离起始顶点s很远，需要遍历完整个图才能找到。这时候，每个顶点都要进出一遍队列，每个边也都会被访问一次，所以广度优先搜索的时间复杂度是O(V+E)，其中V表示顶点的个数，E表示边的个数。对于一个连通图（一个图中的所有顶点都是连通）来说，E肯定要大于等于V-1，所以，广度优先搜索的时间复杂度可以简写为O(E)。

广度优先搜索的空间消耗主要在几个辅助变量 visited 数组、queue 队列、prev 数组上。这三个存储空间的大小都不会超过顶点的个数，所以空间复杂度是 O(V)。

## 深度优先搜索（DFS）

深度优先搜索（Depth-First-Search），简称DFS。深度优先搜索在搜索过程中访问某个顶点后，会递归地访问和这个顶点相邻的所有未访问过的顶点。

查找顶点s到顶点t的路径示例：

![深度优先搜索示例](https://static001.geekbang.org/resource/image/87/85/8778201ce6ff7037c0b3f26b83efba85.jpg)

**深度优先搜索的时间、空间复杂度分析**

从上面的图可以知道，每条边最多会被访问两次，一次是遍历，一次是回退。所以，图上的深度优先搜索算法的时间复杂度是O(E)，E表示边的个数。

深度优先搜索算法的消耗内存主要是 visited、prev 数组和递归调用栈。visited、prev 数组的大小跟顶点的个数 V 成正比，递归调用栈的最大深度不会超过顶点的个数，所以总的空间复杂度就是 O(V)。

## 如何找出社交网络中某个用户的三度好友关系

这个问题就非常适合图的广度优先搜索算法来解决，因为广度优先搜索是层层往外推进的。首先，遍历与起始顶点最近的一层顶点，也就是用户的一度好友，然后再遍历与用户距离的边数为2的顶点，也就是二度好友关系，以及与用户距离边数为3的顶点，也就是三度好友关系。只需要稍加改造一下广度优先搜索代码，用一个数组来记录每个顶点与起始顶点的距离，非常容易就可以找出三度好友关系。

## 总结

广度优先搜索和深度优先搜索是图上的两种最常用、最基本的搜索算法，比起其他高级的搜索算法，比如A*、IDA*等，要简单粗暴，没有什么优化，所以，也被叫做暴力搜索算法。所以**这两种算法仅适用于状态空间不大，也就是说图不大的搜索。**

广度优先搜索，通俗的理解就是，地毯式层层推进，从起始顶点开始，依次往外遍历。广度优先搜索需要借助队列来实现，遍历得到的路径就是，**起始顶点到终止顶点的最短路径。**深度优先搜索用的是回溯思想，非常适合用递归实现。换种说法，深度优先搜索是借助栈来实现的。在执行效率方面，深度优先和广度优先搜索的时间复杂度都是 O(E)，空间复杂度是 O(V)。
