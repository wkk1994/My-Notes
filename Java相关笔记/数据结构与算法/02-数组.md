# 数组

## 数组的定义

数组（Array）是一种线性表数据结构，使用的是一组连续的内存空间来存储具有相同类型的数据。

线性表：数据排列为线型结构，每个线性表上的节点最多包含前后两个方向，如链表、队列、栈、数组等。
非线性表：数据之间的关系并不是简单的前后关系，如二叉树、堆、图等。

数组示例：

![数组示例.png](https://static001.geekbang.org/resource/image/98/c4/98df8e702b14096e7ee4a5141260cdc4.jpg)

## 数组为什么支持随机访问

正是因为数组是线性表，而且是连续的内存空间和相同类型的数据，所以当通过索引访问元素时，会通过下面的公式寻址，计算出该元素的存储的内存地址：

```text
a[i]_address = base_address + i * data_type_size
```

> 数组支持随机访问，根据下标随机访问的时间复杂度是O(1)。

## 数组的“插入”和“删除”

在对数组进行插入或者删除元素时，数组为了保持内存的连续性，可能需要对其中的元素进行移动。

* 插入操作

对于插入操作，如果插入的位置刚好在数组的最后一位，那么就不需要移动其他元素；如果插入的元素是数组的中间k位置，那么就需要移动看k～n后面的元素；如果插入的是数组开头位置，那么就需要移动n个元素。所以插入操作的平均时间复杂度为(1+2+…n)/n=O(n)。

**可能的优化：** 如果数组是有序的，则插入元素后必须要移动其他元素保证顺序性。反之，如果数组没有顺序，只是保存数据，在这种情况下，如果要将某个元素插入到k位置，可以直接将原来k位置的元素移动到数组末尾，把新元素放到k位置，这样可以避免大规模的数据移动。

* 删除操作

对于删除操作，和插入操作类似，如果删除了元素，为了保持内存连续性也需要移动数据。平均情况时间复杂度也为 O(n)。

**可能的优化**

在某些场景下，可以将删除的数据先标记为delete，当数据没有更多空间时，再触发一次真正的删除操作，或者将多次删除操作集中到一次去移动数据，减少移动数据次数。

## 数组的访问越界问题

```c
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

对于上面的代码，数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据前面讲的数组寻址公式，a[3]也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。

**为什么a[3]会定位到i？**“大端小端”；intel 使用的小端模式，数据字节的高低位与内存地址的高低位一致。栈中数据存放是由高地址到地地址，所以压栈顺序为 i ->a[2]->a[1]->a[0]，出栈顺序相反，a[3]取到的值为i。

## 容器类是否可以代替数组

针对数组类型，很多语言提供了容器类，比如Java的ArrayList。

Java的ArrayList最大的优势是可以将很多数组操作的细节封装起来，还有就是支持动态扩容。每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小。

在使用时最好指定初始大小，这样避免扩容的消耗。

注意：

* Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。
* 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。
* 当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList<ArrayList<object> > array。

## 为什么很多编程语言中数组都从0开始编号

从数据的内存模型上来看，“下标”的确切定义是“偏移”，下标0表示的就是偏移为0的位置，也就是首地址，下标k就是偏移k个type_size的位置。

```text
a[k]_address = base_address + k * type_size
```

但是，如果数组从 1 开始计数，那么计算数组元素 a[k]的内存地址就需要进行减一，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。

```text
a[k]_address = base_address + (k-1)*type_size
```

从历史上来看，C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。

## 总结

数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。在平时的业务开发中，可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更合适。

数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，用二分查找，时间复杂度也是 O(logn)。但是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。

数组适合的场景：

1） Java ArrayList 的使用涉及装箱拆箱，有一定的性能损耗，如果特别关注性能，可以考虑数组。
2） 若数据大小事先已知，并且涉及的数据操作非常简单，可以使用数组。
3） 表示多维数组时，数组往往更加直观。
4） 业务开发容器即可，底层开发，如网络框架，性能优化。选择数组。

## Tips

* 二维数组的寻址计算：对于数组a[m][n]中a[i][j]的地址为：address = base_address + ( i * n + j) * type_size
