# 链表

链表不需要连续的内存空间，通过链表节点保存的前置节点指针或后置节点指针形成串联。

## 链表的分类

* 单链表：每个链表节点只保存后置节点。
* 双向链表：每个链表节点保存前置和后置节点。
* 循环链表：是一种特殊的单链表，尾节点的后置节点指向首节点。
* 双向循环链表：是一个特殊的双向链表，尾节点的后置节点指向首节点，首节点的前置节点指向尾节点。

## 链表的插入、删除、查询操作

链表的插入操作的时间复杂度是O(1)。
对于删除指定的节点时间复杂度是O(1)；删除指定值相等的节点的时间复杂度是O(n)。
链表的查询时间复杂度是O(n)。

## 链表 VS 数组性能比较

![链表 VS 数组性能比较](https://static001.geekbang.org/resource/image/4f/68/4f63e92598ec2551069a0eef69db7168.jpg)

数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。

数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。

链表节点需要额外存储前置节点和后置节点的指针，相比于数组会占用多一些存储。链表本身没有大小的限制，天然地支持动态扩容，但是对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片。

在实际的开发中，针对不同类型的项目，要根据具体情况，权衡究竟是选择数组还是链表。

**CPU 的缓存机制:** CPU在读取数据的时候先从一级缓存、二级缓存、三级缓存中获取，缓存中没有再去读内存，在从内存读取数据的时候，会一次行读取一个缓存行的数据（64byte）保存到缓存中，因为数组是连续的内存，所以在读取数组的时候可以一次读取多个数据。

## 常见的缓冲淘汰策略

常见的3种包括先进先出策略FIFO（First In，First Out）、最少使用策略LFU（Least Frenquently Used）、最近最少使用策略LRU（Least Recently Used）。

## 如何基于链表实现 LRU 缓存淘汰算法?

维护一个有序单链表，越靠近表尾部的节点访问时间越早。当访问一个新数据时，需要从链表头部遍历链表。

* 如果在链表中找到数据，将对应数据节点从原来位置移到链表头部，返回数据。
* 如果在链表中没有找到数据：
  * 如果此时缓存链表未满，则将此节点直接插入链表头部。
  * 如果此时缓存链表已经满了，则删除链表尾部的节点，将此节点插入链表头部。

对于在链表中查找数据的时间复杂度是O(n)，可以通过引入一个散列表（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到O(1)。

## 书写正确的链表代码的技巧

### 警惕指针丢失和内存泄漏

对指针的赋值注意指针丢失，或者指针重复形成环。

### 利用哨兵简化实现难度

针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。可以通过哨兵方式解决代码复杂度，通过引入哨兵节点，在任何时候，不管链表是否为空，head指针一直指向这个哨兵节点，这样有哨兵节点的链表叫带头链表，相反的，没有哨兵节点的链表叫作不带头链表。

### 重点留意边界条件处理

代码完成后注意检查边界条件，代码是否能正确处理：

* 如果链表为空时，代码是否能正常工作
* 如果链表只包含一个结点时，代码是否能正常工作
* 如果链表只包含两个结点时，代码是否能正常工作
* 代码逻辑在处理头结点和尾结点的时候，是否能正常工作

单链表反转
链表中环的检测
两个有序的链表合并
删除链表倒数第 n 个结点
求链表的中间结点