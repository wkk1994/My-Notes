# 树

## 树的相关定义

什么是树：

![树示例](https://static001.geekbang.org/resource/image/b7/29/b7043bf29a253bb36221eaec62b2e129.jpg)

以下图为例：A节点就是B节点的父节点，B节点是A节点的子节点。B、C、D这三个节点的父节点相同，它们之间称为兄弟节点。E这样没有父节点的节点称为根节点。没有子节点的节点称为叶子节点或者叶节点，如图中的G、H、I、J、K、L 都是叶子节点。

![示例](https://static001.geekbang.org/resource/image/22/ae/220043e683ea33b9912425ef759556ae.jpg)

## 高度（Height）、深度（Depth）、层（Level）

节点的高度：节点到叶子节点的最长路径（边数）。

节点的深度：根节点到这个节点所经历的边的个数。

节点的层数：节点的深度 + 1。

树的高度：根节点的高度。

![高度、深度、层数示例](https://static001.geekbang.org/resource/image/50/b4/50f89510ad1f7570791dd12f4e9adeb4.jpg)

## 二叉树（Binary Tree）

二叉树，就是每个节点最多有两个子节点，分别是左子节点和右子节点。

常见的二叉树有满二叉树，完全二叉树。

满二叉树：叶子节点全部在最底层，除了叶子节点外，每个节点都有左右两个子节点，如下图的2。

完全二叉树：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，如下图的3。

![二叉树示例](https://static001.geekbang.org/resource/image/09/2b/09c2972d56eb0cf67e727deda0e9412b.jpg)

## 如何表示（或者存储）一棵二叉树

想要存储一颗二叉树，有两种方式。一种是基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法。

### 链式存储法

每个节点有三个字段，其中一个存储数据，另外两个存储指向左右节点的指针。只需要知道根节点，就可以通过左右子节点的指针，把整棵树都串起来。

![链式存储法示意图](https://static001.geekbang.org/resource/image/12/8e/12cd11b2432ed7c4dfc9a2053cb70b8e.jpg)

### 顺序存储法

基于数组的顺序存储法，通过把根节点存储在下标i = 1的位置，那左子节点存储在下标为2 * i = 2的位置，右子节点存储在2 * i + 1 = 3的位置。反过来，下标为i/2的位置存储就是它的父节点。通过这种方式，只要知道根节点的存储位置，就可以通过下标计算，把整棵树串起来。

但是对于上面的存储方式，如果是完全二叉树，仅仅浪费了一个下标为0的存储位置，如果不是完全二叉树回浪费更多的位置。

所以，**如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。**因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因。

## 二叉树的遍历

二叉树经典的遍历方式有三种，前序遍历、中序遍历和后序遍历。其中前、中、后序，表示的是节点与它左右子节点遍历打印的先后顺序。

* 前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。
* 中序遍历是指，对于树中的任意节点来说，先打印它的左子树，再打印它本身，最后打印它的右子树。
* 后序遍历是指。对于树中的任意节点来说，先打印它的左子数，再打印它的右子树，最后打印它本身。

![前中后序遍历示例](https://static001.geekbang.org/resource/image/ab/16/ab103822e75b5b15c615b68560cb2416.jpg)

前中后序遍历代码示例：

```c

void preOrder(Node* root) {
  if (root == null) return;
  print root // 此处为伪代码，表示打印root节点
  preOrder(root->left);
  preOrder(root->right);
}

void inOrder(Node* root) {
  if (root == null) return;
  inOrder(root->left);
  print root // 此处为伪代码，表示打印root节点
  inOrder(root->right);
}

void postOrder(Node* root) {
  if (root == null) return;
  postOrder(root->left);
  postOrder(root->right);
  print root // 此处为伪代码，表示打印root节点
}
```

从前面画的前、中、后序遍历的顺序图，可以看出来，每个节点最多会被访问两次，所以遍历操作的时间复杂度，跟节点的个数 n 成正比，也就是说**二叉树遍历的时间复杂度是 O(n)**。

## 问题

* 给定一组数据，比如 1，3，5，6，9，10。你来算算，可以构建出多少种不同的二叉树？

  如果是完全二叉树，问题可以简化为数组内的元素有多少种组合方式，这样的话，就是 n!。
  卡特兰数

* 按层遍历，如何实现的？

  使用辅助队列，将树结构转换成数组的形式，直接遍历数组就是按层遍历的结果。
