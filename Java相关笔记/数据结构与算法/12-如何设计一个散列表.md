# 如何设计一个散列表

如何设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突的情况下，散列表性能的急剧下降，并且能抵抗散列碰撞攻击？

## 如何设计散列函数

散列函数设计的好坏，决定了散列冲突的概率大小，也直接决定了散列表的性能。

首先，散列函数的设计不能太复杂。过于复杂的散列函数，势必会消耗很多计算时间，也会间接的影响到散列表的性能。其次，散列函数生成的值要尽可能的随机并且均匀分布，这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均。

在实际工作中，还需要考虑各种因素。这些因素有关键字的长度、特点、分布、还有散列表的大小等。

## 装载因子过大怎么处理

对于没有频繁插入和删除的静态数据集合来说，很容易根据数据的特点、分布等设计出完美、极少冲突的散列函数，因为毕竟之前的数据都是已知的。

对于动态散列表来说，数据集合是频繁变动的，无法事先预估要加入的数据个数，所以没办法事先申请一个足够大的散列表。随着数据的慢慢加入，装载因子就会慢慢变大。当装载因子过大时就需要进行调整。

针对散列表，当装载因子多大时，可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到新的散列表中。假设每次扩容都申请一个原来散列表大小两倍的空间。如果原来散列表的装载因子是 0.8，那经过扩容之后，新散列表的装载因子就下降为原来的一半，变成了 0.4。

针对数组的扩容，数据搬移操作比较简单。但是，针对散列表的扩容，数据搬移操作要复杂很多。需要通过散列函数重新计算每个数据的存储位置。

支持动态扩容的散列表，插入操作的时间复杂度分析：插入一个数据，最好的情况是不需要进行扩容。所以时间复杂度是O(1)。最坏情况下，插入操作需要扩容，所以时间复杂度是O(N)。用摊还分析法，均摊情况下，时间复杂度是O(1)。

实际上，对于动态散列表，随着数据的删除，散列表中的数据会越来越少，空闲空间会越来越多。如果我们对空间消耗非常敏感，我们可以在装载因子小于某个值之后，启动动态缩容。当然，如果我们更加在意执行效率，能够容忍多消耗一点内存空间，那就可以不用费劲来缩容了。

装载因子阈值的设置要权衡时间、空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于 1。

## 如何避免低效的扩容

在特殊情况下，当装载因子已经到达阈值，需要先进行扩容，再插入数据。这个时候，如果散列表的数据量很大，搬移操作就很耗时，插入数据就会变得很慢，甚至会无法接受。

为了解决一次性扩容耗时过多的情况，可以将扩容操作穿插在插入操作过程中，分批完成。当装载因子触达阀值之后，只申请新空间，但并不将老数据搬移到新散列表中。

当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，我们都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就都变得很快了。

在这个期间，散列表有两个数组，对于查询操作，可以先在新数组中查找，再在老数组中查找。

通过这样均摊的方法，将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。这种实现方式，任何情况下，插入一个数据的时间复杂度都是 O(1)。

## 如何选择冲突解决方法

常见的冲突解决方式有开放寻址法和链表法。java 中 LinkedHashMap 就采用了链表法解决冲突，ThreadLocalMap 是通过线性探测的开放寻址法来解决冲突。

### 1.开放寻址法

开放寻址法的优点：开放寻址法不像链表法，需要拉很多链表。散列表中数据都存储在数组中，可以有效地利用CPU缓存加速查询速度。而且，这种方法实现的散列表，序列化起来比较简单。链表法包含指针，序列化起来没那么容易（后面会讲）。

开放寻址法的缺点：开放寻址法解决冲突的散列表，在删除数据的时候需要特殊标记已经删除掉的数据。而且，开放寻址法中，所有数据都存储在一个数组中，比起链表法，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这样也导致开发寻址法更浪费内存空间。

**当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因。**

### 2.链表法

链表法的优点：

首先，链表法对内存的利用率比开放寻址法要高。因为，链表节点可以在需要的时候再创建，不需要像开放寻址法那样事先申请好。

链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。

链表法的缺点：

链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存消耗翻倍。而且，因为链表中的节点是零散分布在内存中，不是连续的，所以对CPU缓冲是不友好的，这个对于执行效率也有一定的影响。

实际上，我们对链表法稍加改造，可以实现一个更加高效的散列表。那就是，我们将链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是 O(logn)。这样也就有效避免了前面讲到的散列碰撞攻击。

**基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。**

## 工业级散列表举例分析

分析Java中HashMap这样一个工业级的散列表。

* 1.初始大小

HashMap的默认大小是16，这个默认值是可以设置的。如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高HashMap的性能。

* 2.装载因子和动态扩容

最大装载因子默认是 0.75，当 HashMap 中元素个数超过 0.75*capacity（capacity 表示散列表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。

* 3.散列冲突解决方式

HashMap底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 HashMap 的性能。

于是，在 JDK1.8 版本中，为了对 HashMap 做进一步优化，我们引入了红黑树。而当链表长度太长（默认超过 8）时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点，提高 HashMap 的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。

* 4.散列函数

散列函数的设计并不复杂，追求的是简单高效、分布均匀。

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

其中，hashCode() 返回的是 Java 对象的 hash code。

**何为一个工业级的散列表？工业级的散列表应该具有哪些特性？**

* 支持快速地查询、插入、删除操作；
* 内存占用空间，不能浪费过多的内存空间；
* 性能稳定，极端情况下，散列表的性能也不能退化到无法接收的地步。

对应的实现这些特征的方式：

* 设计一个合适的散列函数；
* 定义装载因子阀值，并且设计动态扩容策略；
* 选择合适的散列冲突解决方式。

## 为什么散列表和链表经常会一起使用？

* LRU 缓存淘汰算法

单单使用链表实现的LRU缓存淘汰算法，查找元素的时间复杂度是O(N)，可以通过加上散列表，实现查找时间复杂度为O(1)。

![链表和散列表结合的LRU实现](https://static001.geekbang.org/resource/image/ea/6e/eaefd5f4028cc7d4cfbb56b24ce8ae6e.jpg)

如图，通过在散列表中查找，实现时间复杂度为O(1)，hnext是为了将结点串在散列表的拉链中。

* Redis 有序集合

redis的有序集合如果单单使用跳表实现，那么当查找指定元素的sorce时，时间复杂度为O(N)。通过加上散列表，在散列表中key为跳表中的元素，value为sorce（分数）。这样将通过元素查找sorce的时间复杂度为O(1)。

* Java LinkedHashMap

LinkedHashMap，其中的“Linked”并不仅仅代表它是通过链表法解决散列冲突的。因为在散列表中，通过散列函数计算之后保存到其中的数据是没有顺序的。LinkedHashMap通过维护一个双向链表，实现支持按照插入顺序遍历数据。同时，它还支持按照访问顺序遍历数据。

```java

// 10是初始大小，0.75是装载因子，true是表示按照访问时间排序
HashMap<Integer, Integer> m = new LinkedHashMap<>(10, 0.75f, true);
m.put(3, 11);
m.put(1, 12);
m.put(5, 23);
m.put(2, 22);

m.put(3, 26);
m.get(5);

for (Map.Entry e : m.entrySet()) {
  System.out.println(e.getKey());
}
// 打印结果：1，2，3，5
```

**LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突。**

散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数，可以将散列表和链表（或者跳表）结合在一起使用。

对于链表来说，支持高效的插入、遍历操作。但是查找的时间复杂度为O(N)，可以通过结合散列表，实现快速的查找操作。

## 问题

* **数据结构和算法的重要性排行榜：连续空间 > 时间 > 碎片空间。**

