# 散列表（Hash Table）

## 散列表的概念

散列表在数组支持按照下标随机访问数据的特征，上扩展而来。

散列表将key进行散列函数计算得到的值称为散列值，将散列值作为数组下标，将数据存储到对应的数组位置上。

## 散列函数

散列函数在散列表中起着至关重要的作用。一个散列函数的好坏很大程度上决定了散列表设计的好坏。

**散列函数设计的基本要求：**

* 散列函数计算得到的散列值是一个非负整数；
* 如果key1 == key2，那么hash(key1) == hash(key2)；
* 如果key1 != key2，那么hash(key1) != hash(key2)。

前面2点很好实现，但是要满足对于第3点几乎不可能的。因为在实际情况中，要找到一个不同key对应的散列值都不一样的函数，几乎不可能的。即便像业界著名的MD5、SHA、CRC等哈希算法，也无法完全避免这种散列冲突。而且，因为数组的存储空间有限，也会加大散列冲突的概率。

## 散列冲突

因为要实现一个不同key对应的散列值都不一样的函数，几乎不可能的。所以需要有方式去解决散列冲突。常见的解决方式有两种：开放寻址法（Open addressing）和链表法（chaining）。

### **1.开放寻址法**

开放寻址法的核心思想是，如果出现散列冲突，就重新探测一个空闲位置，将其插入。

线性探测（Linear Probing）是一个比较简单的探测方法。

当往散列表中插入数据时，如果某个数据经过散列函数计算之后，存储的位置已经被占用，那么就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。

在散列表中查找元素的时候，通过散列函数计算之后，从散列值对应的位置开始，比较数组中的元素是否与要查找的元素相等。如果相等，表名当前元素就是要查找的元素。如果不想等继续向后查找，如果查找的过程中出现空闲位置，就说明要查找的元素并没有在散列表中。

在散列表中删除数据的时候，不能直接将要删除的元素设置为空，因为在查找操作的时候要依赖于空闲位置判断是否查找结束。所以，可以将要删除的元素，特殊标记为deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。

**线性探测的问题**

当插入的数据越来越多，散列冲突发生的可能性就会越来越大，空闲位置就会越来越少，线性探测的时间就会越来越久。极端情况下，可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据。

开放寻址法除了线性探测，还有**二次探测**（Quadratic probing）和**双重散列**（Double hashing）两个比较典型的探测方法。

**二次探测**和线性探测很像，线性探测每次探测的步长是1，那它探测的下标序列就是hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变成原来的“二次方”，也就是说，它探测的下标序列就是hash(key)+0，hash(key)+$1^2%$，hash(key)+$2^2$……

**双重散列**就是不仅使用一个散列函数，而是使用一组散列函数hash1(key)、hash2(key)、hash3(key)...先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。

**装载因子**

不管使用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保存散列表的操作效率，一般情况下，会尽可能保证散列表中有一定比例的空闲槽位。使用装载因子（load factor）来表示空位的多少。

装载因子的计算公式：

```text
散列表的装载因子=填入表中的元素个数/散列表的长度
```

**装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。**

### **2.链表法**

链表法是一种更加常用的散列冲突解决方式，相比于开发寻址法简单很多。在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素都放到相同槽位对应的链表中。

![链表法示意图](https://static001.geekbang.org/resource/image/a4/7f/a4b77d593e4cb76acb2b0689294ec17f.jpg)

当插入元素的时候，只需要通过散列函数计算出散列值，将其插入到对应链表中即可，所以插入的时间复杂度是O(1)。当查找、删除一个元素的时候，同样使用散列函数计算出散列值，然后遍历链表查找或者删除。那么查找、删除对应的时间复杂度是O(k)，k就是链表的长度，理论上k = n/m，其中n表示散列表中数据的个数，m表示散列表中“槽”的个数。

## 问题

* 假设有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？

  遍历访问日志，将url作为key，url出现的次数作为value，存放到散列表中，同时记录下访问次数的最大值 K，时间复杂度 O(N)。然后根据K的大小，如果K值不大可以使用桶排序，排序时间复杂度是O(N)。如果K比较大，使用快速排序，排序时间复杂度是O(NlogN)。

* 有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？

  以第一个字符串数组构建散列表，key 为字符串，value 为出现次数。再遍历第二个字符串数组，以字符串为 key 在散列表中查找，如果 value 大于零，说明存在相同字符串。时间复杂度 O(N)。