# 常用的排序

## 常用的排序

最经典的、最常用的：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。

|排序算法|时间复杂度|是否基于比较|
|--|--|--|--|
|冒泡、插入、选择|O($N^2$)|是|
|希尔、快排、归并|O($NlogN$)|是|
|桶、计数、基数|O(N)|否|

## 如何分析一个排序算法

**排序算法的执行效率**

算法的执行效率通常通过以下三个方面衡量：

* 最好情况、最坏情况、平均情况时间复杂度

  我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。
  为什么要区分这三种时间复杂度呢？第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。

* 时间复杂度的系数、常数、低阶

  时间复杂度反应的是数据规模n很大的时候一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是在实际软件开发中，排序的会可能是10个、100个、1000个等这样小规模的数据。所以，在对同一阶时间复杂度的排序算法性能进行比较的时候，需要把系数、常数、低阶也考虑进来。

* 比较次数和交换（或移动）次数

  在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。

**排序算法的内存消耗**

排序算法的内存消耗可以使用空间复杂度表示，对应的一个概念是原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。

**排序算法的稳定性**

针对排序算法的一个重要指标是稳定性。稳定性是指如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

## 冒泡排序（Bubble Sort）

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

示例：数组4，5，6，3，2，1，从小到大进行排序，第一次冒泡的过程：

![第一次冒泡的过程](https://static001.geekbang.org/resource/image/40/e9/4038f64f47975ab9f519e4f739e464e9.jpg)

这样经过6次冒泡操作后，数组的排序就完成了。

代码示例：

```java

// 冒泡排序，a表示数组，n表示数组大小
public void bubbleSort(int[] a, int n) {
    if(arrays.length <= 1) {
        return;
    }
    boolean flag = false;
    for (int i = 0; i < arrays.length; i++) {
        for (int j = 0; j < arrays.length - i - 1; j++) {
            if(arrays[j] > arrays[j+1]) {
                int temp = arrays[j];
                arrays[j] = arrays[j + 1];
                arrays[j + 1] = temp;
                flag = true;
            }
        }
        // 没有数据交换退出
        if(!flag) {
            return;
        }
    }
}
```

冒泡排序的空间复杂度是O(1)，属于原地排序。在冒泡排序中，只有交换才可以改变两个元素的前后顺序，为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。

**冒泡排序的时间复杂度分析**

在最好的情况下，数组本来就是排好序的，只需要进行一次冒泡操作就可以结束，所以时间复杂度是O(N)。最坏情况下，需要进行n次冒泡操作，所以时间复杂度是O($N^2$)。

平均时间复杂度就是加权平均期望时间复杂度，分析的时候要结合概率论的知识。通过引入有序度、逆序度、满有序度概念分析冒泡排序的平均时间复杂度。排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。又有逆序度 = 满有序度 - 有序度。

一个长度为n的数组，有序度最大为n*(n-1)/2，对应的最小有序度就是0。取平均有序度为n*(n-1)/4，则数组排序过程中就需要n*(n-1)/4次交换数据操作，又因为比较操作肯定要比交换操作多，而复杂度的上限是 O($n^2$)，所以平均情况下的时间复杂度就是 O($n^2$)。

## 插入排序（Insertion Sort）

插入排序是将数据分为两个区间，已排区间和未排区间。初始已排区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

示例：要排序的数据是 4，5，6，1，3，2，其中左侧为已排序区间，右侧是未排序区间。排序的详细过程：

![插入排序的详细过程](https://static001.geekbang.org/resource/image/b6/e1/b60f61ec487358ac037bf2b6974d2de1.jpg)

插入排序包含两种操作，一种是元素的比较，一种是元素的移动。对于不同的查找插入点方法（从头到尾，从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度。

代码示例：

```java
    /**
     * 插入排序，每次插入时从头开始遍历已排序数据
     * @param array
     */
    public static void sortFromHead(int[] array) {
        if(array.length <= 1) {
            return;
        }
        for (int i = 1; i < array.length; i++) {
            int value = array[i];
            for (int j = 0; j < i; j++) {
                if(value < array[j]) {
                    int temp = array[j];
                    array[j] = value;
                    value = temp;
                }
            }
            array[i] = value;
        }
    }

    /**
     * 插入排序，每次插入时从尾开始遍历已排序数据。这样对于有序数组只需要O(N)的时间复杂度
     * @param array
     */
    public static void sortFromTail(int[] array) {
        if(array.length <= 1) {
            return;
        }
        for (int i = 1; i < array.length; i++) {
            int value = array[i];
            int j = i - 1;
            for (; j >= 0; j--) {
                if(value < array[j]) {
                    array[j+1] = array[j];
                }else {
                    break;
                }
            }
            array[j+1] = value;
        }
    }
```

插入排序算法的运行并不需要额外的存储空间，所以空间复杂度为O(1)，属于原地排序。插入排序进行元素比较的时，对于值相同的元素可以选择将元素放到前面出现的元素的前面或后面，属于稳定的排序算法。

**插入排序的时间复杂度分析**

最好情况下，数组都是已经排好序的数据。如果使用的是从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 O(n)。注意，这里是**从尾到头遍历已经有序的数据**。

最坏情况下，数组是倒序的，这时候的时间复杂度是O($n^2$)。

在数组中插入一个数据的平均时间复杂度是O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为O($n^2$)。

## 选择排序（Selection Sort）

选择排序的实现方式类似于插入排序，也分已排区间和未排区间。但是选择排序每次会从未排序区间中找到最小元素，将其放到排序区间的末尾。

示例：数组4，5，6，3，2，1，从小到大进行排序，选择排序的详细过程：

![选择排序的详细过程](https://static001.geekbang.org/resource/image/32/1d/32371475a0b08f0db9861d102474181d.jpg)

选择排序的代码实现:

```java
   /**
     * 选择排序的代码实现
     * @param arrays
     */
    public static void sort(int[] arrays) {
        if(arrays.length <= 1) {
            return;
        }
        int index = 0;
        for (int i = 0; i < arrays.length - 1; i++) {
            int min = i;
            for (int j = i + 1; j < arrays.length; j++) {
                index ++;
                if(arrays[j] < arrays[min]) {
                    min = j;
                }
            }
            int temp = arrays[i];
            arrays[i] = arrays[min];
            arrays[min] = temp;
        }
        System.out.println(index);
    }
```

选择排序空间复杂度为 O(1)，是一种原地排序算法。选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O($n^2$)。

选择排序是一种不稳定的排序算法。原因：选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。（交换位置的时候可能会破坏原有相同元素的顺序）

## 为什么插入排序要比冒泡排序更受欢迎

虽然插入排序和冒泡排序都是原地排序，时间复杂度也都是O($N^2$)。但是，从代码实现上看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。下面这段操作：

```java

// 冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
   int tmp = a[j];
   a[j] = a[j+1];
   a[j+1] = tmp;
   flag = true;
}

// 插入排序中数据的移动操作：
if (a[j] > value) {
  a[j+1] = a[j];  // 数据移动
} else {
  break;
}
```

如果把一个赋值语句的时间粗略地计为单位时间K，冒泡排序中数据交换需要的时间为3*K，插入排序中数据交换需要的时间为K。

所以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 O($n^2$)，但是如果希望把性能优化做到极致，那肯定首选插入排序。插入排序的算法思路也有很大的优化空间，比如希尔排序。

## 希尔排序（Shell Sort）

希尔排序也是一种插入排序，它是在简单插入排序的基础上经过改进之后的一个更高效的版本，也称为缩小增量排序。它与插入排序的不同之处在于，它会优先比较距离较远的元素。

希尔排序是把数组按照索引的一定增量进行分组，对每组使用直接插入排序算法排序；随着增量的逐渐减少，每组包含的数据越来越少，当增量减到1时，整个文件恰被分成一组，排序结束。

**增量的选择**

希尔排序的增量的选择与证明是个数学难题，通常选择增加为数组长度的一半（gap=length/2），缩小增量继续以gap = gap/2的方式，这种增量选择可以用一个序列来表示，{n/2,(n/2)/2...1}，称为增量序列。这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。

![希尔排序的详细过程](https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIOOdfiakqsTRHKk9icjqQZJYuSMeiaLiblRqwhCz6M2Bf1Web7CiaaNtZtAvfXJJY4bxhHiapgxiaYT65EDA/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**希尔排序的时间复杂度分析**

最佳情况：T(n) = O($nlogn$)  最坏情况：T(n) = O($nlogn$)  平均情况：T(n) =O($nlogn$)

希尔排序不是稳定排序。

**归并排序和快速排序都用到了分治思想，适合大规模的数据排序。**

## 归并排序（MergeSort）

归并排序的核心思想是，将要排序的数组，从中间分成前后两部分，然后对前后两部分分别排序，再将排序好的两部分合并在一起，这样整个数组就是有序的了。

![归并排序的详细过程](https://static001.geekbang.org/resource/image/db/2b/db7f892d3355ef74da9cd64aa926dc2b.jpg)

归并排序使用的就是分治思想，将一个大问题分解成小的子问题来解决。小的问题解决了，大问题也就解决了。分治算法一般都是用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧，这两者并不冲突。

归并算法的代码实现：

```java

// 归并排序算法, A是数组，n表示数组大小
merge_sort(A, n) {
  merge_sort_c(A, 0, n-1)
}

// 递归调用函数
merge_sort_c(A, p, r) {
  // 递归终止条件
  if p >= r  then return

  // 取p到r之间的中间位置q
  q = (p+r) / 2
  // 分治递归
  merge_sort_c(A, p, q)
  merge_sort_c(A, q+1, r)
  // 将A[p...q]和A[q+1...r]合并为A[p...r]
  merge(A[p...r], A[p...q], A[q+1...r])
}

// merge函数伪代码
merge(A[p...r], A[p...q], A[q+1...r]) {
  var i := p，j := q+1，k := 0 // 初始化变量i, j, k
  var tmp := new array[0...r-p] // 申请一个大小跟A[p...r]一样的临时数组
  while i<=q AND j<=r do {
    if A[i] <= A[j] {
      tmp[k++] = A[i++] // i++等于i:=i+1
    } else {
      tmp[k++] = A[j++]
    }
  }
  
  // 判断哪个子数组中有剩余的数据
  var start := i，end := q
  if j<=r then start := j, end:=r
  
  // 将剩余的数据拷贝到临时数组tmp
  while start <= end do {
    tmp[k++] = A[start++]
  }
  
  // 将tmp中的数组拷贝回A[p...r]
  for i:=0 to r-p do {
    A[p+i] = tmp[i]
  }
}
```

### 归并排序的性能分析

**归并排序是否属于稳定排序**

归并排序是否属于稳定排序，关键要看merge()函数，也就是在合并子数组的时候，如果 A[p…q]和 A[q+1…r]之间有值相同的元素，那我们可以像伪代码中那样，先把 A[p…q]中的元素放入 tmp 数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一个稳定的排序算法。

**归并排序的时间复杂度分析**

提前的一个结论：**不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。**

因为归并排序涉及递归操作，所以时间复杂度为：`T(n) = T(a) + T(b) + k`，其中 K 等于将两个子问题 b、c 的结果合并成问题 n 的结果所消耗的时间。

推导归并排序的时间复杂度：

```text
T(n) = T(n/2) + T(n/2) + n
     = 2*T(n/2) + n
     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
     = 2^k * T(n/2^k) + k * n
```

当 T($n/2^k$)=T(1) 时，也就是 $n/2^k$=1，得到 k=$log_2n$ 。我们将 k 值代入上面的公式，得到 T(n)=$Cn+nlog_2n$。如果我们用大 O 标记法来表示的话，T(n) 就等于 O($nlogn$)。所以归并排序的时间复杂度是 O($nlogn$)。

归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。

**归并排序的空间复杂度**

归并排序的时间复杂度虽然是O($nlogn$)，但是它并没有像快速排序那样应用广泛，因为归并排序不属于原地排序算法。如果按照分析递归时间复杂度的方法，通过递推公式来求解，那整个归并过程需要的空间复杂度就是 O($nlogn$)。实际上，递归代码的空间复杂度并不能像时间复杂度那样累加。重要的一点是尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。

## 快速排序

快速排序算法利用的也是分治思想。如果要排序数组中下标从 p 到 r 之间的一组数据，那么选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。然后遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。然后根据分治、递归的处理思想，可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。

![快速排序的详细过程](https://static001.geekbang.org/resource/image/4d/81/4d892c3a2e08a17f16097d07ea088a81.jpg)

快速排序也是使用递归进行排序的，递推公式为：

```text
递推公式：
quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)

终止条件：
p >= r
```

快速排序的代码实现：

```java

// 快速排序，A是数组，n表示数组的大小
quick_sort(A, n) {
  quick_sort_c(A, 0, n-1)
}
// 快速排序递归函数，p,r为下标
quick_sort_c(A, p, r) {
  if p >= r then return
  
  q = partition(A, p, r) // 获取分区点
  quick_sort_c(A, p, q-1)
  quick_sort_c(A, q+1, r)
}

// 原地分区函数的伪代码，
partition(A, p, r) {
  pivot := A[r]
  i := p
  for j := p to r-1 do {
    if A[j] < pivot {
      swap A[i] with A[j]
      i := i+1
    }
  }
  swap A[i] with A[r]
  return i
}
```

分区数组部分函数的实现：通过索引i将数组分为两部分，一部分是小于分区元素的部分，通过遍历数组将小于分区元素的数据移动到前面。

快速排序获取pivot过程：

![快速排序获取pivot](https://static001.geekbang.org/resource/image/08/e7/086002d67995e4769473b3f50dd96de7.jpg)

### 快速排序的性能分析

快排是一种原地、不稳定的排序算法。

**时间复杂度分析**

快排也是用递归实现的。对于递归代码的时间复杂度，根据前面总结的公式，在这里也还是适用的。如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的。所以，快排的时间复杂度也是 O($nlogn$)。

这个时间复杂度成立的前提是每次分区操作，选择的pivot都很合适，正好能将大区间对地一分为二。对于比较极端的例子，选择选择了最大或者最小的数据作为pivot，那么每次分区得到的两个分区都是不均等的。就需要n次分区操作，这种情况下，时间复杂度退化成了O($n^2$)。

## 快速排序和归并排序的对比

归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。

![快速排序和归并排序的对比](https://static001.geekbang.org/resource/image/aa/05/aa03ae570dace416127c9ccf9db8ac05.jpg)

## 线性排序

桶排序、计数排序、基数排序，因为这些排序算法的时间复杂度都是线性的（O(N)），所以这类排序算法称为线性排序。

## 桶排序（Bucket sort）

桶排序的核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据在进行单独排序。桶内排序完成之后，再将桶内的数据按顺序取出，组成的序列就是有序的了。

![桶排序的详细过程](https://static001.geekbang.org/resource/image/98/ae/987564607b864255f81686829503abae.jpg)

**桶排序的时间复杂度分析**

如果要排序的数据有n个，假设均匀的分到m个桶中，那么每个桶的数据为 (k = n/m)个。每个桶内使用快速排序，时间复杂度为O(klogk)。m个桶的时间复杂度就是O(nlog(n/m))。当桶的个数m接近个数n时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。

**桶排序能否取代快速排序**

不能。因为实际上桶排序对数据的要求很苛刻。

首先，数据需要很容易的就能划分成m个桶，并且桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。

其次，数据在各个桶中的分布必须是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。

**桶排序比较适合用在外部排序中。**所谓的外部排序就是数据在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。

**桶排序在外部排序解决10GB的订单排序问题**

问题：有 10GB 的订单数据，希望按订单金额（假设金额都是正整数）进行排序，但是内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。

可以先扫描一遍数据，查看订单所处的数据范围。假设订单金额的范围是1～10000。可以按照1~1000，1001～2000...分成100个桶，每个桶对应一个文件。接下来遍历订单数据，将对应的数据放到对应桶所在的磁盘文件中。在理想情况下，如果订单金额在1～10000中均匀分布，那订单会被均匀划分到 100 个文件中，每个小文件中存储大约 100MB 的订单数据，我们就可以将这 100 个小文件依次放到内存中，用快排来排序。等所有文件都排好序之后，只需要按照文件编号，从小到大依次读取每个小文件中的订单数据，并将其写入到一个文件中，那这个文件中存储的就是按照金额从小到大排序的订单数据了。

不过，订单按照金额在 1 元到 10 万元之间并不一定是均匀分布的 ，所以 10GB 订单数据是无法均匀地被划分到 100 个文件中的。有可能某个金额区间的数据特别多，划分之后对应的文件就会很大，没法一次性读入内存。这又该怎么办呢？针对这些划分之后还是比较大的文件，我们可以继续划分，比如，订单金额在 1 元到 1000 元之间的比较多，我们就将这个区间继续划分为 10 个小区间，1 元到 100 元，101 元到 200 元，201 元到 300 元…901 元到 1000 元。如果划分之后，101 元到 200 元之间的订单还是太多，无法一次性读入内存，那就继续再划分，直到所有的文件都能读入内存为止。

## 计数排序（Counting sort ）

计数排序和桶排序的思想差不多，当要排序的n个数据，所处的范围不大时，比如最大值为k，可以将数据分成k个桶，每个桶存放数据相同的数据，省了桶内排序的时间。

计数排序的应用：对考生的分数进行排序。考生的满分是 900 分，最小是 0 分，这个数据的范围很小，所以可以分成 901 个桶，对应分数从 0 分到 900 分。根据考生的成绩，将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。

**如何获得考生的排名？？**

假设有8个考生，成绩分别为2，5，3，0，2，3，0，3。可以分成6个桶，分别是0，1，2，3，4，5。遍历一遍数据可以得到考生成绩桶的分布：

![考生成绩桶分布](https://static001.geekbang.org/resource/image/ad/c9/adc75672ef33fa54b023a040834fcbc9.jpg)

对上面的数组顺序求和，就可以得到小于等于当前分数k的考生的个数（k为数组的索引值）。

![小于等于分数k的考生个数](https://static001.geekbang.org/resource/image/dd/1f/dd6c62b12b0dc1b3a294af0fa1ce371f.jpg)

这样就可以计算考生的排名了。假设排名后的数组为R[8]，开始遍历考生的成绩，第一个成绩为3，对应上面的数组，成绩小于等于3的考生个数为7，也就是说该考生成绩为数组R[8]中的第7个元素，所以该考生应放入R[6]中，这时候小于等于3的考生个数就少一个，所以上面的c[3]应该减一等于6。继续扫描考生成绩直到排序完成。这样就可以得到考生的排名了。

![考生排名详细过程](https://static001.geekbang.org/resource/image/1d/84/1d730cb17249f8e92ef5cab53ae65784.jpg)

**计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。**

比如，还是拿考生这个例子。如果考生成绩精确到小数后一位，我们就需要将所有的分数都先乘以 10，转化成整数，然后再放到 9010 个桶内。再比如，如果要排序的数据中有负数，数据的范围是[-1000, 1000]，那我们就需要先对每个数据都加 1000，转化成非负整数。

## 基数排序（Radix sort）

当对数据比较大的数据进行排序时，比如手机号，单词等，桶排序、计数排序就不能派上用场了。但是像这样的数据进行比较有一个规律，假设要比较两个手机号码 a，b 的大小，如果在前面几位中，a 手机号码已经比 b 手机号码大了，那后面的几位就不用看了。

可以借助稳定排序算法，先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。

![基数排序详细过程](https://static001.geekbang.org/resource/image/df/0c/df0cdbb73bd19a2d69a52c54d8b9fc0c.jpg)

**注意**，这里按照每位来排序的排序算法要是稳定的，否则这个实现思路就是不正确的。因为如果是非稳定排序算法，那最后一次排序只会考虑最高位的大小顺序，完全不管其他位的大小关系，那么低位的排序就完全没有意义了。

根据每一位来排序，可以使用桶排序或者计数排序，可以做到时间复杂度为O(n)。如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数排序，总的时间复杂度是 O(k*n)。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n)。

有的时候，排序的数据并不都是等长的，比如单词，可以将所有的单词补齐到相同的长度，位数不够的可以在后面补“0”，因为根据ASCII 值，所有字母都大于“0”，所以补“0”不会影响到原有的大小顺序。这样就可以继续用基数排序了。

**基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进关系，如果a数据的高位比b数据的高位大，那剩下的地位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到O(N)了。**

## 总结

有桶排序、计数排序、基数排序，它们对要排序的数据都有比较苛刻的要求，应用不是非常广泛。但是如果数据特征比较符合这些排序算法的要求，应用这些算法，会非常高效，线性时间复杂度可以达到 O(n)。

桶排序和计数排序的排序思想是非常相似的，都是针对范围不大的数据，将数据划分成不同的桶来实现排序。基数排序要求数据可以划分成高低位，位之间有递进关系。比较两个数，我们只需要比较高位，高位相同的再比较低位。而且每一位的数据范围不能太大，因为基数排序算法需要借助桶排序或者计数排序来完成每一个位的排序工作。

## 问题

* https://mp.weixin.qq.com/s/HQg3BzzQfJXcWyltsgOfCQ

* 计数排序，获取排名时为什么要从尾开始遍历数组A？

  从头遍历就不属于稳定排序，从尾部遍历可以保证相同的数据后出现的数据仍在前出现的后面。
