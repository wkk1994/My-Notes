# 常见的算法思想

常见的算法思想有：贪心算法（贪婪算法）、分治算法、回溯算法、动态规划。

## 贪心算法

贪心算法（greedy algorithm）有很多经典的应用，比如霍夫曼编码、Prim和Kruskal最小生成树算法、还有Dijkstra单源路径算法。

### 什么是贪心算法

在对问题进行求解时，将问题分为若干小问题，在若干小问题上每次都做出当前最好的选择，即对于问题求解不是从整体上考虑选择最优解，而是在局部上选择最优解。

### 贪心算法的分析过程

* 是否可以使用贪心算法：针对一组数据，定义了限制值和期望值，希望从数据中选取几个数据，在满足限制值的条件下，期望值最大。这类问题可以使用贪心算法。
* 尝试使用贪心算法解决：在当前的限制条件下，选择对贡献值对大的数据。
* 贪心算法验证：将每一步选择的数据合并，就是用贪心算法得到的最优解，验证这个最优解是不是最优的。

> 注意：如果上一步的最优解，会影响下一步的选择，这类问题使用贪心算法求得的不一定是最优解。

### 霍夫曼编码

霍夫曼编码是一种十分有效的编码方式，广泛使用在数据压缩中，其压缩率通常是在20%~90%之间。

霍夫曼编码的核心思想是根据贪心算法，将出现频率比较多的字符使用稍微短一些的编码；而出现频率比较少的字符，用稍微长一些的编码。

详细实现：https://time.geekbang.org/column/article/73188

### 课后题

* 在一个非负整数 a 中，我们希望从中移除 k 个数字，让剩下的数字值最小，如何选择移除哪 k 个数字呢？

1、可以借助一个栈，从高位数据开始入栈，如果次地位大于栈顶元素入栈，如果小于，弹出栈顶元素直到栈顶元素小于入栈元素，同时计数k减1，判断k不为0继续重复操作，如果k已经减到0，还有元素，将剩余的入栈。如果元素已经入完栈，k不为0，则弹出相应的个元素。最后栈内元素及为结果。

* 假设有 n 个人等待被服务，但是服务窗口只有一个，每个人需要被服务的时间长度是不同的，如何安排被服务的先后顺序，才能让这 n 个人总的等待时间最短？

2、由等待时间最短的开始服务

## 分治算法

### 什么是分治算法

分治算法的核心思想是分而治之，通过将问题分解成n个子问题，并且每个子问题和原问题的结构相似，递归地解决这些子问题，然后再合并处理结果，就得到原问题的解。
分治算法是一种处理问题的思路，一般使用递归来实现。

### 哪些问题可以使用分治算法实现

* 原问题可以分解成具有相同模式的小问题；
* 原问题分解成子问题可以独立求解，子问题之间没有相关性；
* 具有分解终止条件，也就是当问题足够小的时候可以直接求解；
* 可以将子问题合并成原问题，而且这个合并的世间复杂度不能过高，否则就起不到减小算法总体复杂度的效果了。

### 分治思想解决问题举例


### 分治思想在海量数据处理中的应用

在海量数据处理中，如果数据量分常大，没办法一次性放到内存中，这个时候可以使用分治思想。将海量数据划分为几个小的数据集合，让每个小集合加载到内存中来解决，然后再将小数据集合合并成大数据集合。

### MapReduce

MapReduce是如何使用分治思想提高大数据处理的效率？

MapReduce本质是分治思想，在实现上，MapReduce框架只是一个任务调度器，底层依赖GFS来存储数据，依赖Borg管理机器。它从GFS中拿数据，交给Brog中的机器执行，并且时刻监控机器的执行情况，一旦出现机器宕机、进度卡壳等，就会重新从Brog中调度一台机器来执行。

MapReduce的经典例子，统计文件中单词出现的频率。除此之外，它还可以用来处理数据与数据之间没有关系的任务，比如对网页分析、分词等，每个网页可以独立的分析、分词，而这两个网页之间并没有关系。网页几十亿、上百亿，如果单机处理，效率低下，我们就可以利用 MapReduce 提供的高可靠、高性能、高容错的并行计算框架，并行地处理这几十亿、上百亿的网页。

## 回溯算法

回溯算法的应用很广泛，比如深度优先搜索算法利用的就是回溯思想、正则表达式匹配、编译原理中的语法分析等。

很多经典的数学问题都可以使用回溯算法解决，比如数独、八皇后、0-1背包、图的着色、旅行商问题、全排列等。

### 什么是回溯算法

回溯算法的思想很简单，在解决问题时，当遇到分叉点时，先选择任意一个分支进行执行，如果分支不能解决问题，再回到这个分叉点，选择另一个分支进行执行。

### 回溯算法应用举例

* 八皇后

8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子。

* 0-1背包问题

背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？
使用回溯算法的时间复杂度是O(2^n)

## 动态规划

动态规划比较适合用来求解最优问题，比如求最大值、最小值等等。它可以非常显著地降低时间复杂度，提高代码的执行效率。

### 什么是动态规划

动态规划解决问题的思路是将问题分成n个阶段，每个阶段会做出一个决策，当前层阶段的决策做完之后，会基于当前层的决策推导出下一层的状态集合。这样可以避免每层状态的指数级增长。

### 动态规划应用举例

* 0-1背包问题

使用动态规划解决0-1背包问题的时间复杂度是 O(n*w)，空间复杂度是O(n\*w)，n为物品的数量，w为背包的最大载重量。

[ZeroAndOneKnapsackDynamic#knapsack](https://github.com/wkk1994/java-algo/tree/master/src/main/java/com/wkk/demo/algo/learn/algo/thought/recall/ZeroAndOneKnapsackDynamic.java)

可以通过优化使用一维数组来保存背包状态，做到空间复杂度为O(w)。

[ZeroAndOneKnapsackDynamic#knapsack2](https://github.com/wkk1994/java-algo/tree/master/src/main/java/com/wkk/demo/algo/learn/algo/thought/recall/ZeroAndOneKnapsackDynamic.java)

* 0-1 背包问题升级版

背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，价值不同，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总价值最大？

使用动态规划解决时间复杂度是 O(n*w)，空间复杂度也是 O(n*w)

[ZeroAndOneKnapsackUpdate#knapsack](https://github.com/wkk1994/java-algo/tree/master/src/main/java/com/wkk/demo/algo/learn/algo/thought/recall/ZeroAndOneKnapsackUpdate.java)

大部分的动态能解决的问题都可以使用回溯算法来解决，只不过回溯算法的时间复杂度太高了。动态规划在执行效率上要高很多，但是空间复杂度比较高，所以，动态规划可以看做是空间换时间的算法思想。

### 一个模型三个特征

什么样的问题适合使用动态规划解决？可以总结为”一个模型三个特征“。

**一个模型**

一个模型是指动态规划适合解决的问题模型，这个模型定义为”多阶段决策最优解模型“。一般使用动态规划解决最优解问题，最优解问题一般要经历多个决策阶段。每个决策阶段都对应一组状态，通过寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。

**三个特征**

**1.最优子结构**

最优子结构指的是，问题的最优解包含子问题的最优解。反过来，可以通过子问题的最优解，推导出问题的最优解。也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。

**2.无后效性**

无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，只关心前面阶段的状态值，不关心这个状态是怎么推导出来的。第二层含义是，某个阶段的状态一旦确定后，就不受之后的阶段的影响了。

**3.重复子问题**

不同的决策序列，到达某个相同的阶段时，可能出现重复的状态。

