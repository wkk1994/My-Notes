# 二叉树、平衡二叉树、B-树和B+树

## 二叉树-BST（binary search/sort tree）

二叉树又称二叉查找/搜索/排序树。二叉树的特点是任何节点的左子节点的键值都小于当前节点的键值，右子节点的键值都大于当前节点的键值；每个节点最多只有两个子节点。 顶端节点称为根节点，没有子节点的节点称为叶节点。

### 二叉树的遍历

遍历有三种方式：前序遍历，中序遍历和后序遍历。

* 前序遍历是指：对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树-----根左右。
* 中序遍历是指：对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树------左根右。
* 后序遍历是指：对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印它本身------左右根。

### 二叉树的分类

* 普通二叉树：由一个根节点加上两棵分别称为左子树和右子树组成
* 满二叉树： 叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点
* 完全二叉树：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大

![二叉树分类](../../../youdaonote-images/D790950C2B904837B9EF2C2E6204F0B9.png)

### 二叉树的优点和问题

二叉树的搜索性能接近二分查找，最好的情况查询的时间复杂度是$log_2{n}$，理想的树的高度为$log_2n$。相比于连续内存空间的二分查找的优点是，改变BST树结构（插入与删除节点）不需要移动大段的内存数据，甚至通常是常数开销。但是二叉树最差的情况下生成的二叉查找树就是一个链表，这时候二叉树变得不平衡了，高度太高，从而导致查找效率的不稳定。

## 平衡二叉树

平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。满二叉树和完全二叉树都是平衡二叉树，但是非完全二叉树也可以是平衡二叉树。平衡二叉树的常用实现方法有AA树、AVL树、红黑树、树堆Treap、伸展树等。

![平衡二叉树](../../../youdaonote-images/CEE264018A384289B64E2D3803162A4F.png)

### AVL树

AVL树，在满足二叉查找树特性的基础上，要求每个节点的左右子树的高度差不能超过1。但是每次在插入或者删除的时候，为了符合平衡二叉树严格的条件，需要进行一些调整，比如左旋、右旋等操作，使其再次符合平衡二叉树的条件。

#### 4种旋转

[参考](https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247486260&idx=1&sn=c358ed6662b3f6ae9a00c3f52293c2e8&chksm=ebf6d34bdc815a5db21673728b57383bef2a793ef95e4dffa778e71f40e4ea7519963bd1422c&scene=27#wechat_redirect)

* 左旋

![左旋](../../../youdaonote-images/87F806A772F140DC8526883145A82386.gif)

* 右旋

![右旋](../../../youdaonote-images/29A6154628F24EE7B74A4BD5C8483F53.gif)

* 左右旋转

![左右旋转](../../../youdaonote-images/AF1119BABE214D788258A5A7C63C1321.gif)

* 右左旋转

![右左旋转](../../../youdaonote-images/6CDD6481FABC4A75855411C12943B817.gif)

如果要是再插入和删除非常频繁的场景下，平衡二叉树每一次更新都必须要进行调整，这样太耗时了，性能也会受到很大影响。

### 红黑树（Red-Black Tree）

为了避免AVL树在频繁更新过程中，所带来的维持树结构的时间消耗，从而引入了红黑树。Java中的TreeMap，TreeSet， Java8中的HashMap的实现也将链表替换成了红黑树。

红黑树在原来BST的基础上添加了以下特性：

* 根节点是黑色的；
* 树的任一节点是红色或者黑色；
* 每个红色节点的两个子节点都是黑色的；
* 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
* 从任一节点到其每个叶子的所有路径包含相同数目的黑色节点；
* 空节点默认黑色。

RBTree在本质上还是一棵BST树，但是它在插入和删除数据的时候会通过变色和自旋来保持树的平衡，即保证树的高度在[$log_2N$,$log_2N$+1]，将树的查找时间复杂度始终保持在$log_2N$,同时RBTree的插入和删除时间复杂度也都是$log_2N$,所以RBTree的查找接近于理想的BST。

#### 红黑树的自旋

[参考](https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&mid=2650247467&idx=1&sn=db34c24004281c69a47e5cbf1c9507b2&chksm=88636044bf14e95236e1323940ce616de0438a458fc4cc97dc91b114fcef403ca32a2af1e578&scene=27#wechat_redirect)

RBTree的自旋主要目的是为了让节点的颜色符合上面的性质，从而使树的高度达到平衡。RBTree的旋转分为左旋和右旋，左边子节点升到父节点位置为右旋，右边子节点升到父节点为左旋。

## B-树（B-Tree）

对于二叉树，每次搜索最多需要$log_2N$次磁盘IO查询，与内存相比从磁盘读取数据的速度会慢上百倍千倍甚至万倍，因此，应当尽量减少从磁盘中读取数据的次数。 另外，从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读。 

B-树是一课m阶树，相对于平衡二叉树，每个节点存储了更多的键值（key）和数据（data），并且每个节点拥有更多的子节点，子节点的个数一般称为阶，高度也会很低。基于这个特性，B树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。

### B-树的特性：

* 关键字集合分布在整颗树中；
* 任何一个关键字出现且只出现在一个结点中；
* 搜索有可能在非叶子结点结束；
* 其搜索性能等价于在关键字全集内做一次二分查找。

![B树](../../../youdaonote-images/F05E033EC9AF41C29F9C49C0006103A2.png)

假如要查找key值为28的数据，那么在上图B树中查找的流程如下： 
1. 先找到根节点，判断28在键值17和35之间，我们那么我们根据根节点中的指针p2找到页1。 

2. 将28和页1中的键值相比较，28在26和30之间，我们根据页1中的指针p2找到页2。 

3. 将28和页2中的键值相比较，发现有匹配的键值28，键值28对应的数据就能找到。

## B+树

### B+树的特性：

* 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
* 不可能在非叶子结点命中；
* 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
* 更适合文件索引系统。

![B+树](../../../youdaonote-images/88332C2FF5884A0AB5A20501844352EE.png)

**B+树与B树相比有什么不同：**

* B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。
    如果B+树一个节点可以存储1000个键值，那么3层B+树可以存储1000×1000×1000=10亿个数据。一般根节点是常驻内存的，所以一般我们查找10亿数据，只需要2次磁盘IO。 
* 因为B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而B树因为数据分散在各个节点，要实现这一点是很不容易的。    

## 参考

* [为什么MySQL用B+树做索引](https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650125030&idx=1&sn=1c2a09a80547159b336e7ea25d7f4955&chksm=f36bafc7c41c26d14cf685d42369e82b3ead547a919b6e86b8068ef88464cb8ac13f72271a74&scene=27#wechat_redirect)
* [红黑树](https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&mid=2650247467&idx=1&sn=db34c24004281c69a47e5cbf1c9507b2&chksm=88636044bf14e95236e1323940ce616de0438a458fc4cc97dc91b114fcef403ca32a2af1e578&scene=27#wechat_redirect)
* [平衡二叉树 AVL树结构详解 [Java实现]](https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247486260&idx=1&sn=c358ed6662b3f6ae9a00c3f52293c2e8&chksm=ebf6d34bdc815a5db21673728b57383bef2a793ef95e4dffa778e71f40e4ea7519963bd1422c&scene=27#wechat_redirect)
* [二叉树、平衡二叉树、红黑树、B-树、B+树、B*树、T树之间的详解和比较](https://blog.csdn.net/windgs_yf/article/details/86534384)