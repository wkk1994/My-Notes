# 第 24 课 分布式消息--消息队列基础

## 1. 系统间通信方式

系统间的通信方式常见的有：

* 基于文件：跨机器的可以基于网络文件，或者定期复制文件。
* 基于共享内存
* 基于IPC：IPC(Inter-Process Communication)进程间通信。
* 基于Socket
* 基于数据库
* 基于RPC

各种模式的优缺点：

* 文件：不方便，不够及时。
* socket：使用麻烦，需要定义数据格式等，多数情况下不如RPC。
* 数据库：不实时，需要定时查询数据库是否有消息进来，但是经常有人用数据库来模拟消息队列。
* RPC：调用关系复杂，系统需要相互依赖，同步处理，压力大需要进行限流。

期望有一种通信方式可以实现以下：

* 可以实现异步的消息通信：对于大任务的处理异步处理，防止阻塞主线程。
* 简化参与各方的复杂依赖关系。
* 在请求量很大的时候，有缓冲。
* 在某些情况下能保障消息的可靠性，甚至顺序：有些业务场景，比如股票交易，需要保障消息处理的顺序性，如果不能保证顺序会导致后面的人先买入成功，前面的人买不到会吃亏。

这种实现的方式就是**MQ**，也叫做Message Queue（消息队列）/Messaging System（消息系统）/Message Middlewire（消息中间件）。

## 2.从队列到消息服务

### 从队列到消息服务

Message Queue/Messaging System/Message Middlewire：

![消息系统模式](https://note.youdao.com/yws/api/personal/file/WEBa8ca750320e812c7fb015e226cbb75f6?method=download&shareKey=76234947f6c54dc5227374799425d4ac)

* 消费者：作为消费者，有推和拉两种模式。推：消息系统主动向消费者推送消息；拉：消费者向消息系统获取消息。
* 什么是消息？：能够传递信息的数据都是消息。

### MQ的四大特性

对比其他通信模式，MQ的优势在于：

* 异步通信：异步通信，减少线程等待，特别是处理批量、耗时操作。
* 系统解耦：系统之间不直接调用，降低依赖，即使是不在线也能保证通信最终完成。
* 削峰填谷：压力大的时候，缓冲部分请求消息，类似于背压处理。
* 可靠通信：提供多种消息模式、服务质量、顺序保障等。

> 背压：简单理解就是上游生产者参数数据的速度超过了消费者消费的速度而产生的问题。[参考](https://www.zhihu.com/question/49618581)

## 3.消息模式与消息协议*

### 消息处理模式

常见的有两种消息模式

* 点对点：PTP，Point-To-Point，对应于Queue。一个发送的消息只会发送到一个队里中。

* 发布订阅：PubSub，Publish-Subscribe，对应于Topic。广播模式。

### 消息处理的保障

在消息中间件中常见的三种QoS，用来平衡性能和可靠性：

* At most once，至多一次，消息可能丢失但是不会重复发送；
* At least once，至少一次，消息不会丢失，但是可能重复；
* Exactly once，精确一次，每条消息肯定会被传输一次且仅一次。

> QoS：Quality of Service，服务质量，是针对的消息语义，不是业务语义的。

消息处理的事务性：

* 通过确认机制实现事务性，消息被消费需要确认消息；
* 可以被事务管理器管理，甚至可以支持XA。

### 消息的有序性

同一个Topic或Queue的消息，保障按顺序投递。

注意：如果做了消息分区，或者批量预取之类的操作，可能就没有顺序了。

### 集成领域圣经

《企业集成模式》可以认为是SOA/ESB/MQ等理论基础。

### 消息协议

* STOMP：简单文本对象消息协议。
* JMS：J2EE的消息服务，只是定义了一组接口类似于JDBC。
* AMQP：高级的消息队列协议，比较完备的消息协议，RabbitMQ默认支持的协议。
* MQTT：比较完备的消息协议，IBM提出的协议，主要用作物联网领域，发出的探测包很小，所以适用于物联网这种网络不稳定的环境。
* XMPP：常用于即时通讯。
* Open Messaging：阿里巴巴的RocketMQ，提出的消息协议。

#### JMS（Java Message Service）

### 消息队列的通用结构

![消息队列的通用结构](https://note.youdao.com/yws/api/personal/file/WEBb57886eb12819fe81d53878685b446c2?method=download&shareKey=670182b9e9309f75e9a4b3b026669aa2)

常见的调用模式：

* oneway：只是调用没有返回。
* rr：请求响应模式，调用之后有响应。

**MQ怎么实现rr？**

在A系统发送的消息头中添加处理响应的queue名称，B系统处理完毕之后，将处理完成的消息发送到消息头中的队列，这样A系统消费该队列，可以获取到处理的响应。

### 开源消息中间件/消息队列

消息中间件到目前为止一般认为发展了三代：

* ActiveMQ/RabbitMQ
  主要是基于JMS和AMQP，不支持堆积，主要是靠内存。都支持Queue和Topic。
* Kafka/RocketMQ
  支持堆积，内存满了会写到磁盘，基于WAL技术。RocketMQ一开始是和Kafka同源的。Kafka是现在二代MQ的事实标准。第二代的MQ一般只支持Topic。
* Apache Pulsar
  支持存储和计算的分离，存储节点和对外的服务节点进行分离。

> JMQ：京东的消息中间件，就是封装的ActiveMQ。
> Apache Qpid是AMQP协议的参考实现。
> artemis是ActiveMQ的6.0版本，还没有正式发布。

### 技术选型
消息中间的技术选型可以从下面四个方面分析：

* 关于性能：吞吐量/延迟。
* 关于选型：场景与指标。
* 关于开发：抽象与封装。
* 关于维护：稳定性/高可用。

> 技术选型，可以先做个POC测试，测试是否满足业务需求。

## 4.ActiveMQ消息中间件

### ActiveMQ介绍

ActiveMQ是高可靠的、事务性的消息队列。当前应用最广泛的开源消息中间件。

### 主要功能

* 支持多种语言和协议编写的客户端
  支持的语言客户端：Java、C、C++、Python、PHP等。
  支持的应用协议：OpenWire（ActiveMQ自己提出的协议）、STOMP、REST、XMPP、AMQP、MQTT。

* 完全支持JMS1.1和J2EE1.4规范。
* 与Spring很好地集成，也支持常见J2EE服务器。
* 支持多种传送协议:in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA。
* 支持通过JDBC和journal（文件持久化）提供高速的消息持久化。
* 实现了高性能的集群模式。

### 使用场景

ActiveMQ的使用场景：

* 1、所有需要使用消息队列的地方；
* 2、订单处理、消息通知、服务降级等等；
* 3、特别地，纯java实现，提供了一个jar的包，支持嵌入到应用系统。

## Tips

* camel：消息迁移。
* roaringbitmap做去重。
* ZMQ，认为是一个通信库，不认为是一个mq，是一个极度优化的通信库，在Socket API之上做了一层封装，将网络通讯、进程通讯和线程通讯抽象为统一的API接口。
* DLQ：Dead Letter Queue，死信队列。
* 看技术书可以先选择自己需要的章节了解。
* POC测试：Proof of Concept，即概念验证。通常指在进行产品选型或技术选型时，对产品或技术进行验证测试，测试是否满足功能和性能需求。
