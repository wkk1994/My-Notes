# 分布式服务-深入分布式服务化

## 1.分布式服务治理*

### 从RPC走向服务化->微服务架构

在具体的分布式服务的业务场景中，除了能够调用远程方法，还需要考虑很多东西。
具体有：

* 1.多个相同的服务如何管理

  可以通过集群部署服务、将服务分组、通过版本将不同的服务进行划分等方式，进行服务的部署和管理。

* 2.服务注册发现机制

  对于多个服务的上线与下线需要通知到每个相依赖的服务，可以通过注册中心进行服务的注册与发现。

* 3.如何负载均衡，路由等集群功能

  要实现负载均衡和路由功能，防止每个服务的负载不均。

* 4.熔断，限流等治理能力

  对于特殊场景下突然的大流量请求，要提供熔断措施和限流策略。

* 5.心跳，重试等策略

* 6.高可用、监控、性能等等

  分布式服务化下，服务更多，调用更容易出现问题，要有高可用、监控等的方案。

> 分布式和集群的区别：集群是一组机器都是对等的，提供相同的功能；分布式是机器之前是有相互协作关系的。

### RPC与分布式服务化的区别

RPC：属于技术概念，属于分布式服务化的一个技术实现。
分布式服务化：首先服务是业务语义的，偏向于业务与系统的集成。使用RPC技术，并且完成上面的非功能性需求能力就可以说是一个分布式服务框架。在具体使用时需要注意如何设计分布式的业务服务。

注意：服务 != 接口，服务可以用接口或接口文档之类的语言描述。

### 分布式服务化与SOA/ESB的区别

**SOA/ESB**

ESB是SOA的集中式实现，服务都是通过ESB容器代理调用，ESB进行增强。

![ESB系统调用模式](https://note.youdao.com/yws/api/personal/file/WEBfbb27c37f635d8f639f832fc3af6e82f?method=download&shareKey=48bdf5f7ef4c6f91ea5dabc85a2e1130)

ESB的核心内容一般包括：

* 服务元数据的管理：包括服务的注册、发现、生命周期等；
* 协议适配：支持各种集成和通信协议；
* 中介服务：支持消息的处理和转换，比如协议之间的转换rpc转成mq；
* 治理与监控：服务调用统计、服务降级、流控等；
* 安全性：数据安全、服务调用安全、身份验证等；
* 还有其他的比如事务管理、高可用、高可靠性等。

web容器+MQ+EIP = ESB。

**分布式服务化**

分布式服务化是SOA的另一种选择，它以不同的方式将ESB的功能都实现了一遍。

分布式服务化是服务之间直接调用，侧边增强。使用配置中心、注册中心等代替ESB中的服务注册发现等。对于增强的部分，有状态的部分单独放到xx中心中去；无状态的部分，放到应用侧，比如框架治理、RPC调用。

![分布式服务化模式](https://note.youdao.com/yws/api/personal/file/WEB535d583312dad4d546ecb4810fca643b?method=download&shareKey=770838fb8c622e8a868c110aa5f81863)

> SOA（面向服务架构）：是一种企业级级的架构风格，不是面向单个系统，对于企业所有的业务能力，变成可以复用的服务接口和实现就是SOA（服务接口和实现可以使用RPC技术）。
> SOA -- 架构 -- ESB -- WebService --WSDL -- SOAP

## 2.配置/注册/元数据中心*

### 配置、注册、元数据有什么异同

配置中心（ConfigConter）：管理系统需要的配置参数信息，比如端口号、日志级别。
注册中心（RegistryConter）：管理系统的服务注册，提供发现和协调能力。
元数据中心（MetadataConter）：管理各个节点使用的元数据信息。

相同点：都需要保存和读取数据/状态，数据变更时都要通知。
不同点：配置是全局非业务参数，注册中心是运行期临时状态，保存运行时的服务节点的信息，元数据是业务模型，比如描述服务的数据，这些数据一般不和服务节点有关系，就是用来描述当前服务提供的能力。

**三个中心是逻辑概念，不一定全都有，也不一定各个实现，可以是Config和Registry在一起实现。**

### 为什么需要配置中心

* 大规模集群下，配置新的管理，批量更新配置时，单个机器更改效率太慢。
* 大公司和金融行业，一般要求开发、测试、运维分离（物理隔离）。
* 运行期的一些开关的控制，需要修改配置之后不需要重启。

常见的配置中心：Zookeeper、etcd、Nacos、Apollo...

### 为什么需要注册中心

让消费者动态感知生产者集群的状态变化。

操作：

* hello.html -> ok，淘宝早期会在程序下放一个hello.html，当服务启动之后，人工通过脚本讲hello.html写入启动成功的字符；其他程序通过访问hello.html就可以知道该应用是否启动成功。

* DNS、VIP、Nginx: 受网络缓存的影响。

* 主动报告 + 心跳：当前主流方式。

### 为什么需要元数据中心

一般情况下，没有元数据中心，问题不是很大。有了元数据中心，服务之前相互调用不再需要携带元数据信息了。

**一般配置中心可以实现元数据中心，元数据中心不是必须的，可以使用配置中心替换。**

### 如何实现配置/注册/元数据中心

配置/注册/元数据中心最核心的要素有：

* 需要有存取数据的能力，特别是临时数据的能力。
* 需要有数据变化的实时通知机制，全量或增量。如果没有通知机制，就需要客户端进行每隔一段时间进行垃圾数据，这样会有一定的延迟，所以没有这个功能也可以。

配置/注册/元数据中心一般底层都是依赖一些Zookeeper、Nacos、Apollo等基座来设计和实现的。在主流的基座一般都有namespace的概念，用来在顶层隔离不同环境。

> zk中没有namespace的概念，一般使用第一个根节点作为namespace。Dubbo中使用group作为namespace，如果不配置就使用dubbo最为顶层的namespace。
> ZK做注册中心，集群大的时候性能不高，ZK在选举期间不可用。
> apache curator是目前常用的zookeeper的客户端，因为它从注册中心获取数据后缓存到本地，可以减少读取。
> dubbo-admin项目如果想要进行接口测试，需要将元数据信息打开，Zookeeper中没有元数据，没办法进行测试。

## 3.服务的注册与发现*

### 服务注册

服务提供者启动时：

* 将自己注册到注册中心（比如zk实现）的临时节点。
* 停止或者宕机时，临时节点消失。

注册的数据格式：

* 节点key，代表当前服务（或者服务+版本）。
* 多个子节点，每一个为一个提供者的描述信息。

### 服务发现

服务消费者启动时：

* 从注册中心代表服务的主节点拿到多个代表提供者的临时节点列表，并本地缓存。
* 根据router和loadbalance算法从其中的某一个执行调用。
* 如果可用的提供者集合发生变化时，注册中心通知消费者刷新本地缓存的列表。

## 4.服务的集群与路由*

### 服务集群

对于完全能力相同的多个服务，希望它们协同工作，分摊流量。这个时候可以使用路由或负载均衡来进行协同工作。

### 服务路由（Service Route）

服务的路由目的和网关一样，根据路由策略将请求发到指定的一些服务上。
常见的路由策略有：

* 基于IP段的过滤：比如只将请求发送到位于同一个网段的请求上。
* 将服务设置上tag，消费者根据自己的tag进行匹配调用：dubbo支持在声明服务者和依赖消费者的时候添加tag属性。

### 服务负载均衡（Service LoadBalance）

负载均衡的目的是在通过路由后获取到的地址中，根据负载均衡策略选取具体的请求地址。

多个不同策略，原理不同，目的基本一致（尽量均匀）：

* Random（带权重）
* RoundRobin（轮询）
* LeastActive（快的多给）：记录每个消费者目前的请求处理数量，将请求发送到目前处理数量少的机器上。
* ConsistentHashLoadBalance（同样参数请求到一个提供者）：使用一致性哈希算法，让相同参数的请求落到一个提供者，dubbo默认分了160个段，每个提供者负载一段区域。

## 5.服务的过滤与流控

### 服务过滤

所有复杂的处理，都可以抽象为管道+过滤器模式（Channel+Filter）。
可以用来实现额外的增强（类似AOP），也可以中断当前处理流程，返回特定数据。

### 为什么需要服务流控（Flow Control）

系统会故障属于正常现象，但是，当系统出现问题时，是直接不服务，还是保持部分服务能力？

这就引入了稳定性工程。

保持部分服务能力是最佳选择，然后在问题解决后恢复正常状态。这个过程在响应式编程中称为回弹性（Resilient）。

**需要流控的本质原因是，输入请求大于处理能力。**

### 服务流控

流控有三个级别：

* 限流（内部线程数，外部调用数或数据量）：这种实现方式可以通过在应用内进行全局计数，限制请求量；对于线程数可以直接修改参数进行生效。
* 服务降级（去掉不必要的业务逻辑，只保留核心逻辑）：对于服务调用可以添加开关进行控制是否调用服务，压力大时直接不调用。
* 过载保护（系统短时间不提供新的业务处理服务，积压处理完后再恢复输入请求）：简单粗暴的方式是直接在前端将流量拒绝。

> sentinel是一个实现比较完备的流控框架，它的实现是先定义资源，再定义一个包含资源的规则。
> shiro也是一个流控框架。

## Tips

* DevOps/SRE: DevOps：运维开发人员，与业务相关的运维由开发人员去做；SRE：系统稳定性工程师，与基础设施有关的运维由SRE运维。
* API：API Manager
* 元数据(Metadata): 描述业务数据的数据。
* OOP OOD SOA TDD DDD
* MDA MDD: 基于元模型的测试开发，先用元模型定义模型，模型再来描述业务。简单来说就是模型是系统的抽象，通过这个模型可以开发出多个类似的系统；而元模型又是模型的抽象，通过元模型可以定义多个模型。
* 学以致用，如何将学习到的东西用到日常工作中去？？
