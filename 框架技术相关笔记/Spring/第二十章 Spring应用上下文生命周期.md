# Spring应用上下文生命周期

主要讲解Spring上下文的启动的流程，主要围绕方法`org.springframework.context.support.AbstractApplicationContext#refresh`讲解。

## Spring应用上下文启动准备阶段

准备阶段方法：`AbstractApplicationContext#prepareRefresh`

* 1.记录启动时间：startupDate
* 2.标识状态：close(true)、active(true)
* 3.初始化PropertySource：initPropertySources()

  AbstractApplicationContext#initPropertySources默认是空方法，AbstractApplicationContext的子类，自定义对PropertySource进行了初始化。
  比如：`GenericWebApplicationContext#initPropertySources`，会初始化servletContext相关的PropertySource。

* 4.校验Environment中必须属性：ConfigurablePropertyResolver#validateRequiredProperties

  这里校验的必要属性就是在ConfigurablePropertyResolver#setRequiredProperties方法重中设置的属性。

* 5.初始化早期事件监听器集合：earlyApplicationListeners

  ~~earlyApplicationListeners用来保存ApplicationEventMulticaster初始化之前注册的ApplicationEvent，并在ApplicationEventMulticaster初始化后注册到ApplicationEventMulticaster中。~~
  earlyApplicationListeners并不是这样的，applicationListeners才是存放ApplicationEventMulticaster初始化之前注册的ApplicationEvent，目前earlyApplicationListeners的尚不知晓。

* 6.初始化早期事件集合：earlyApplicationEvents

  因为AbstractApplicationContext的发送事件委托给ApplicationEventMulticaster实现，所以在ApplicationEventMulticaster初始化之前，earlyApplicationEvents用来保存暂存要发送的事件，当ApplicationEventMulticaster初始化之后再发送事件。

## BeanFactory创建阶段

BeanFactory创建阶段的方法：`AbstractApplicationContext#obtainFreshBeanFactory`

这个方法的作用是刷新Spring上下文底层的BeanFactory并返回BeanFactory，刷新BeanFactory的方法为`AbstractApplicationContext#refreshBeanFactory`，目前在Spring中的有两个该方法的实现分别是`AbstractRefreshableApplicationContext#refreshBeanFactory`和`GenericApplicationContext#refreshBeanFactory`。Spring中与Web相关的上下文都继承了AbstractRefreshableApplicationContext，而其他的Spring上下文都继承了GenericApplicationContext。

`AbstractRefreshableApplicationContext#refreshBeanFactory`的实现：

* 如果已经存在BeanFactory，销毁BeanFactory中的Bean，并关闭BeanFactory。
* 创建BeanFactory：createBeanFactory，创建的BeanFactory类型为DefaultListableBeanFactory，并且在Spring中创建的应用上下文中的BeanFactory都是DefaultListableBeanFactory。
* 设置BeanFactory的id，这个id可以有语义或没有语义。
* 定制BeanFactory的属性：`AbstractRefreshableApplicationContext#customizeBeanFactory`

  当前这个方法中只改变了BeanFactory的两个值：
  
  * allowBeanDefinitionOverriding：是否允许BeanDefinition重复定义，默认值为true。spring-boot 2.1开始设置为false了，不允许重复定义BeanDefinition。
  * allowCircularReferences：是否允许循环依赖，默认值为true。

* 加载BeanDefinition：`AbstractRefreshableApplicationContext#loadBeanDefinitions`，不同的子类实现的行为不一样，比如ClassPathXmlApplicationContext实现的方式是从xml中读取BeanDefinition；AnnotationConfigWebApplicationContext实现的方式是从注解中获取。
* 关联新建的BeanFactory到当前Spring上下文中：`this.beanFactory = beanFactory`

`GenericApplicationContext#refreshBeanFactory`中的实现：

它的实现比较简单，就是设置refreshed为true，并设置BeanDefinition的id。

> spring-boot 2.1开始不允许重复定义BeanDefinition，这样的改动实际上是不合理的，一般子类的实现时它的限制不应该小于父类。
> **关联新建的BeanFactory到当前Spring上下文这一步**，在历史版本中都是使用synchronized进行了同步限制，新版本开始取消了synchronized同步限制，并且在getBeanFactory方法中也取消了synchronized同步限制。

## BeanFactory准备阶段

BeanFactory在使用前有一个准备阶段，方法`AbstractApplicationContext#prepareBeanFactory`，在这一阶段主要是注册了两个BeanPostProcessor：ApplicationContextAwareProcessor和ApplicationListenerDetector；注册了4个可依赖注入的Bean，分别是BeanFactory、ResourceLoader、ApplicationEventPublisher和ApplicationContext；注册了三个单例的Environment Bean，分别是Environment、SystemProperties、SystemEnvironment。

具体实现：

* 关联ClassLoader

  这里需要ClassLoader的原因是，在进行Bean实例化时需要通过ClassLoader进行Class字节码的加载，虽然对Class字节码的加载，BeanFactory可以使用加载自身的ClassLoader，不用特地关联，但是，由于ClassLoader有隔离机制，所以这里关联的ClassLoader可以是一些自定义的ClassLoader，用来实现比如隔离等特定的目的。

* 设置Bean表达式处理：这里是设置EL表达式的解析方式。
* 添加PropertyEditorRegister实现：AbstractBeanFactory可以添加多个PropertyEditorRegister，用来实现类型转换。
* 添加Aware回调接口的实现ApplicationContextAwareProcessor

  ApplicationContextAwareProcessor的作用是在Bean初始化完成之后，对Bean检查是否是某些Aware接口的实现，并注入特定的Bean实例，这些接口有：EnvironmentAware、EmbeddedValueResolverAware、ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware、ApplicationContextAware。

* 忽略Aware回调接口作为依赖注入接口

  ```java
  beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
  beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
  beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
  beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
  beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
  beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);
  ```

  这里的作用是上述Aware接口的实现类如果使用自动绑定的形式注入属性，那么它在自动绑定对应的属性时会被忽略，即不绑定。举例：
  
  ```java
  public class CustomizeApplicationContextAware implements ApplicationContextAware {
  private ApplicationContext applicationContext;
  private User user;
  // setter gatter
  ```
  
  在自动绑定阶段，上面的属性user会正常注入，但是applicationContext会被忽略。
  为什么？因为实现Aware接口的Bean实例会在ApplicationContextAwareProcessor类中，调用对应的set方法注入对应的Bean实例，所以前面可以忽略，避免多次注入。

* 注册可依赖注入的对象（ResolvableDependency）：BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext。

* 注册ApplicationListenerDetector对象

  ApplicationListenerDetector实现了BeanPostProcessor两个阶段，分别是Bean初始化完成之后和Bean销毁之前。在Bean初始化完成之后，如果Bean是单例并且类型为ApplicationListener，通过方法`AbstractApplicationContext#addApplicationListener`注册为事件监听器。
  Bean销毁之前，如果Bean类型是ApplicationListener，将bean从事件监听中除移。

* 注册LoadTimeWeaverAwareProcessor：与AOP相关。

* 注册单例对象：Environment、Java System Properties以及OS环境变量。

## BeanFactory后置处理阶段

BeanFactory的后置处理阶段对应有两个方法：`AbstractApplicationContext#postProcessBeanFactory`和`AbstractApplicationContext#invokeBeanFactoryPostProcessors`。

`postProcessBeanFactory`方法：

AbstractApplicationContext的`postProcessBeanFactory`方法为空方法，由子类实现。

`AnnotationConfigServletWebApplicationContext#postProcessBeanFactory`方法分析：

* 首先调用了父类的postProcessBeanFactory方法，即`GenericWebApplicationContext#postProcessBeanFactory`。
* 如果basePackages不为空，使用ClassPathBeanDefinitionScanner扫描Bean并注册。
* 如果annotatedClasses不为空，注册annotatedClasses指定的Class。

`GenericWebApplicationContext#postProcessBeanFactory`方法分析：

* servletContext不为空，注册Aware回调接口ServletContextAwareProcessor，并忽略ServletContextAware。
* 注册Web容器的Bean作用域（request、session、application）
* 注册Web容器相关的Environment Bean，有servletContext、servletConfig、contextParameters、contextAttributes。

`invokeBeanFactoryPostProcessors`方法：

该方法主要有两个步骤：

* 调用BeanFactoryPostProcessor或BeanDefinitionRegistryPostProcessor的后置处理方法。
* 注册LoadTimeWeaverAwareProcessor对象。

`PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List<org.springframework.beans.factory.config.BeanFactoryPostProcessor>)`方法用来执行BeanFactoryPostProcessor或BeanDefinitionRegistryPostProcessor的实现类的后置处理方法，主要步骤：

* 1.执行BeanDefinitionRegistryPostProcessor的后置处理方法

  这里的前提是当前的BeanFactory是BeanDefinitionRegistry的子类，DefaultListableBeanFactory实现了BeanDefinitionRegistry所以条件成立。
  接口BeanDefinitionRegistryPostProcessors继承了BeanFactoryPostProcessor接口，所以在这一步骤会执行两个方法`postProcessBeanDefinitionRegistry`和`postProcessBeanFactory`。
  这里的执行顺序可以看成是四个步骤：
  * 1.执行传入的BeanFactoryPostProcessor列表中类型为BeanDefinitionRegistryPostProcessor的`postProcessBeanDefinitionRegistry`方法。
  * 2.从BeanFactory中获取类型为BeanDefinitionRegistryPostProcessor的Bean实例，将这些Bean实例中实现了PriorityOrdered接口的进行排序，然后执行`postProcessBeanDefinitionRegistry`方法。
  * 3.从BeanFactory中获取类型为BeanDefinitionRegistryPostProcessor的Bean实例，将这些Bean实例中实现了Ordered接口的进行排序，然后执行`postProcessBeanDefinitionRegistry`方法。
  * 4.从BeanFactory中获取类型为BeanDefinitionRegistryPostProcessor的Bean实例，将上面已经执行的过滤，然后执行`postProcessBeanDefinitionRegistry`方法。
    这里会一直循环执行，直到不存在没执行的BeanDefinitionRegistryPostProcessor为止。为什么？因为在`postProcessBeanDefinitionRegistry`方法也可以注册BeanDefinitionRegistryPostProcessor。
  * 5.执行BeanDefinitionRegistryPostProcessor中的`postProcessBeanFactory`方法

* 2.如果BeanFactory不是BeanDefinitionRegistry的子类，执行传入的BeanFactoryPostProcessor列表的`postProcessBeanFactory`方法。
* 3.开始执行BeanFactoryPostProcessor的`postProcessBeanFactory`方法。

  这里执行的BeanFactoryPostProcessor和上面类似，先将实现PriorityOrdered接口的Bean实例排序并执行`postProcessBeanFactory`方法，然后再是实现了Ordered接口的，最后是剩下的。不过这里执行的BeanFactoryPostProcessor实例，需要排除上面的BeanDefinitionRegistryPostProcessor的实例，而且最后执行的也没有循环执行。

* 4.清除BeanFactory中的BeanDefinition等缓存数据。

> 对于BeanFactory后置处理阶段，如果开发者想要扩展，通过实现BeanFactoryPostProcessor或BeanDefinitionRegistryPostProcessor接口即可。

## BeanFactory注册BeanPostProcessor阶段

`AbstractApplicationContext#registerBeanPostProcessors`方法，底层依赖`PostProcessorRegistrationDelegate#registerBeanPostProcessors(ConfigurableListableBeanFactory, AbstractApplicationContext)`，注册BeanPostProcessor阶段和执行BeanFactoryPostProcessors方法类似。主要步骤：

* 注册BeanPostProcessorChecker

  用于打印日志（所有 BeanPostProcessor 还没有全部实例化就有 Bean 初始化完成）。

  BeanPostProcessorChecker中有数字记录当前它注册为BeanPostProcessor时系统中的BeanPostProcessor实例数量，在`postProcessAfterInitialization`方法，它会检查记录的BeanPostProcessor实例数量和当前BeanFactory中的是否大于，如果大于，就认为当前的Bean初始化时，BeanPostProcessor还没注册完，就输出日志。

* 注册BeanFactory中的BeanPostProcessor的实现

  从BeanFactory中获取所有类型为BeanPostProcessor的BeanName列表，然后先将实现了PriorityOrdered接口的进行排序，然后注册为BeanPostProcessor；再将实现了Ordered接口的进行排序，注册为BeanPostProcessor；最后将剩下的注册为BeanPostProcessor。

* 注册MergedBeanDefinitionPostProcessor

  将上一步获取到的BeanPostProcessor中类型为MergedBeanDefinitionPostProcessor的进行排序后注册，实际上注册会先删除BeanPostProcessor再注册，所以这一步相当于将BeanPostProcessor中类型为MergedBeanDefinitionPostProcessor进行后移注册了。

  通常 MergedBeanDefinitionPostProcessor 需要 BeanDefinition 的元信息充分的准备，所以放到最后。

* 注册BeanPostProcessor：ApplicationListenerDetector

  ApplicationListenerDetector在BeanFactory准备阶段已经注册过了，这里再注册的目的是将ApplicationListenerDetector移动的BeanPostProcessor处理链的尾部。
  为什么？在BeanPostProcessor处理中可能对Bean实例进行代理返回另一个Bean对象了，所以要将ApplicationListenerDetector放到最后，确保注册的ApplicationListener是代理后的。

## 初始化内建Bean：MessageSource

`AbstractApplicationContext#initMessageSource`方法的实现步骤：

它会在BeanFactory本地检查是否存在messageSource的Bean，如果存在将它作为当前上下文的messageSource赋值，如果MessageSource类型为HierarchicalMessageSource并且Parent为空，设置parent MessageSource。

当MessageSource不存在，就默认创建一个DelegatingMessageSource，并且设置parent MessageSource，注册到BeanFactory中。

实际上在默认的Spring上下文中，MessageSource都是一个空对象，如果要覆盖这个MessageSource实现自己的MessageSource，最好在BeanFactoryPostProcessor中，因为这一步是在postProcessBeanFactory方法中调用中，可以在初始化MessageSource方法前调用。

在spring-boot中会自定义一个MessageSource用来替换Spring上下文中默认的MessageSource。

## 初始化内建Bean：Spring事件广播器

方法：`AbstractApplicationContext#initApplicationEventMulticaster`，这一步主要初始化Spring上下文所依赖的事件注册和广播器ApplicationEventMulticaster。

先检查当前BeanFactory本地是存在applicationEventMulticaster，存在就直接获取，不存在就创建一个SimpleApplicationEventMulticaster作为默认实现，并且作为单例Bean注册到BeanFactory中。

## Spring上下文刷新阶段

方法`AbstractApplicationContext#onRefresh`默认为空实现，子类覆盖的方法：

* org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#onRefresh

  对主题进行设置，themeSource。

* org.springframework.web.context.support.GenericWebApplicationContext#onRefresh

  对主题进行设置，themeSource。

* org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext#onRefresh

  和上面的不同，会创建一些web相关的东西。

* org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext#onRefresh

  和上面的不同，会创建一些web相关的东西。

* org.springframework.web.context.support.StaticWebApplicationContext#onRefresh

  对主题进行设置，themeSource。

在onRefresh中，子类可以做的扩展是基于之前已经初始化好的属性进行扩展，比如MessageSource，ApplicationEventMulticaster。

## Spring事件监听器注册阶段

方法`AbstractApplicationContext#registerListeners`主要步骤为：

* 添加当前Spring应用上下文关联的ApplicationListener对象集合。

  这里添加的ApplicationListener来源applicationListeners属性，applicationListeners存的是在ApplicationEventMulticaster未初始化前，通过`AbstractApplicationContext#addApplicationListener`注册的事件监听器。

* 添加BeanFactory中所注册的ApplicationListener。

  从BeanFactory中获取类型为ApplicationListener的BeanName，并注册到ApplicationEventMulticaster。注意这里注册的是BeanName，相当于延迟加载的形式，在需要的时候再初始化对应的Bean实例。

* 广播ApplicationEventMulticaster未初始化前的Spring事件。

  从earlyApplicationEvents中获取早期的Spring事件，并通过ApplicationEventMulticaster进行广播。
