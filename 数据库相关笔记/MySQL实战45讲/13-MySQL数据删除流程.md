# MySQL数据删除流程

为什么数据删除表空间并没有减少
一个InnoDB表包含两部分，表结构定义和数据。

## 表结构和数据的存放

* 表结构
 MySQL8.0版本之前，表结构以表名+.frm为后缀名的文件存放。MySQL8.0之后，已经允许将表结构定义放在系统数据表中。表结构占用空间很少。

* 表数据
 表数据既可以存在共享表空间里，也可以是单独的文件。由参数`innodb_file_per_table`控制。<br/><br/>
 
  `innodb_file_per_table`: 参数为OFF表示数据放在系统共享表空间，也就是和数据字典放在一起。
 参数为NO表示每个InnoDB表数据存储在一个以.idb为后缀的文件中。从 MySQL 5.6.6 版本开始，默认值是ON。推荐设置为NO，这样删除整个表的时候，可以用drop table命令回收表空间。

## 数据删除流程

对于InnoDB中数据存储方式都是按页存储的，当删除一条数据时，当前数据所在的空间只会标记为已删除不会被回收。当再次插入一个和之前数据的上下限id内的数据时，就可能会复用这个位置。但是，磁盘的大小不会缩小。这就是为什么数据删除了但是表空间大小没有变化的主要原因。

当删除一个数据页上的所有数据时，整个数据页就可以被复用了。表空间大小也会缩小。

**数据页的复用和记录的复用不同：** 记录的复用，只限于满足范围条件的数据才可以复用。当整个数据页从 B+ 树里面摘掉以后，可以复用到任何位置。如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用。

如果使用delete删除整个表的数据时，所有的数据页都会被标记可复用。但是磁盘上文件不会变小。

**不止是删除数据会造成空洞，插入数据也会：** 如果数据时按照索引递增顺序插入的，那么索引是紧凑的。但是如果数据时随机插入的，就可能造成索引的数据页分裂。（之前有讲过）

## 重建表

可以通过重建表收缩表空间。新建一个与表 A 结构相同的表 B，然后按照主键 ID 递增的顺序，把数据一行一行地从表 A 里读出来再插入到表 B 中。

在重建表的时候，InnoDB 不会把整张表占满，每个页留了 1/16 给后续的更新用。

`alter table A engine=InnoDB`命令来重建表。

MySQL5.5版本之前的重建表过程：
state1：新建一个和表A结构相同的临时表。
state2：将表A的数据按照主键ID递增的顺序插入临时表。
state3：将表A改名为临时表，临时表改名为表A。
state4：删除临时表。
在这个过程中，如果有新的数据要写入到表A的话就会造成数据丢失。这个DDL不是Online的。

MySQL5.6版本开始引入Online DDL，对于这个操作流程做了优化。重建表过程：
1.建立一个临时文件，扫描表 A 主键的所有数据页；
2.用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；
3.生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中，对应的是图中 state2 的状态；
4.临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件，对应的就是图中 state3 的状态；
5.用临时文件替换表 A 的数据文件。
对于一个大表来说，Online DDL 最耗时的过程就是拷贝数据到临时表的过程，这个步骤的执行期间可以接受增删改操作。所以，相对于整个 DDL 过程来说，锁的时间非常短。对业务来说，就可以认为是 Online 的。

对于很大的表来说，重建表这个操作是很消耗 IO 和 CPU 资源的。因此，如果是线上服务，你要很小心地控制操作时间。如果想要比较安全的操作的话，推荐使用 GitHub 开源的 gh-ost 来做。

## Online 和 inplace，Copy Table

### Copy Table

MySQL5.5版本之前的重建表方式，是在server层完成表的复制。

### inplace

在重建表的过程中，重建出来的数据放在“tmp_file”里的，这个临时文件是在InnoDB内部创建出来的。整个DDL过程在InnoDB内部完成。对于server层来说，把数据移动到临时表是一个原地操作，称之为inplace。
注意：索引的inplace是不需要重新建表，直接在原表上操作的。

重建表时`alter table t engine=InnoDB`等同于`alter table t engine=innodb,ALGORITHM=inplace`也可以指定拷贝表的方式`alter table t engine=innodb,ALGORITHM=copy`。

给 InnoDB 表的一个字段加全文索引：`alter table t add FULLTEXT(field_name);`这个过程是 inplace 的，但会阻塞增删改操作，是非 Online 的。

**Online 和 inplace关系：**
* DDL 过程如果是 Online 的，就一定是 inplace 的；
* inplace 的 DDL，有可能不是 Online 的。截止到 MySQL 8.0，添加全文索引（FULLTEXT index）和空间索引 (SPATIAL index) 就属于这种情况。

**一般索引的创建：** 
* `Copy Table`：创建索引是通过临时表拷贝的方式实现的。新建一个带有新索引的临时表，将原表数据全部拷贝到临时表，然后Rename，完成创建索引的操作。这个方式创建索引，创建过程中，原表是可读的。但是会消耗一倍的存储空间。
* `Inplace`：索引创建在原表上直接进行，不会拷贝临时表。原表同样可读的，但是不可写。
* `Online`：在Inplace的基础上，在遍历聚簇索引，收集记录并插入到新索引的过程中，原表记录可修改。而修改的记录保存在Row Log中。当聚簇索引遍历完毕，并全部插入到新索引之后，重放Row Log中的记录修改，使得新索引与聚簇索引记录达到一致状态。Online Add Index只有在重放Row Log最后一个Block时锁表，减少了锁表的时间。

**optimize table、analyze table 和 alter table 这三种方式重建表的区别：**
* 从 MySQL 5.6 版本开始，alter table t engine = InnoDB（也就是 recreate）默认的就是Online流程了；
* analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了 MDL 读锁；
* optimize table t 等于 recreate+analyze。     e 