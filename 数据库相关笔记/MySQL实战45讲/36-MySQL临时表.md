# MySQL临时表

## 内存表和临时表的区别

* 内存表：指的是Memory引擎的表，建表语法是create table … engine=memory。这种表的数据都保存在内存里，系统重启时会被清空，但是表结构还在。其他特征和正常表一样。
* 临时表：可以使用各种引擎类型，如果是使用 InnoDB 引擎或者 MyISAM 引擎的临时表，写数据的时候是写到磁盘上的。当然，临时表也可以使用 Memory 引擎。

## 临时表的特性

* 1.建表语法是create temporary table …。
* 2.一个临时表只能被它创建的session访问，对其他线程不可见。
* 3.临时表可以和普通表重名。
* 4.session内有同名的临时表和普通表的时候，show create语句，以及增删改查语句访问的是临时表。
* 5.show tables不显示临时表。
* 6.临时表在这个session结束的时候，会自动删除。

**为什么临时表就特别适合之前的 join 优化这种场景？**

* 不同 session 的临时表是可以重名的，如果有多个 session 同时执行 join 优化，不需要担心表名重复导致建表失败的问题。
* 不需要担心数据删除问题。如果使用普通表，在流程执行过程中客户端发生了异常断开，或者数据库发生异常重启，还需要专门来清理中间过程中生成的数据表。而临时表由于自动回收，所以不需要这个额外的操作。

## 临时表的应用

由于不用担心线程之间的重名冲突，临时表经常会被用在复杂查询的优化过程中。其中，分库分表系统的跨库查询就是一个典型的使用场景。

一般分库分表的场景，就是把一个逻辑上的大表分散到不同的数据库实例上。比如，将一个大表t，按照字段f拆分成1024个分表，然后分布到32个数据库实例上。一般情况下，这种分库分表系统都有一个中间层 proxy。不过，也有一些方案会让客户端直接连接数据库，也就是没有 proxy 这一层。

这样的架构中，分区key的选择是以“减少跨库和跨表查询”为依据。如果大部分的语句都会包含f的等值查询，那么就使用f作为分区键。这样在proxy层解析完SQL语句以后，就能确定这条语句到哪个分表做查询。

比如`select v from t where f=N;`可以通过分区规则（N/1024）来确定需要的数据被放在了哪个分表上。

如果一个查询语句是：`select v from t where k >= M order by t_modified desc limit 100;`这样，这个时候查询条件里没有用到分区字段f，只能到所有的分区中去查找满足条件的所有行，然后统一做 order by 的操作。这种情况下，有两种比较常用的思路。

* **第一种思路是，在 proxy 层的进程代码中实现排序。**
  这种方式的优势是处理速度快，拿到分库的数据以后，直接在内存中参与计算。不过，这个方案的缺点也比较明显：
  1.需要的开发工作量比较大。如果涉及到复杂的操作，比如group by，join等，对中间层的开发能力要求比较高。
  2.对 proxy 端的压力比较大，尤其是很容易出现内存不够用和 CPU 瓶颈的问题。
* **另一种思路就是，把各个分库拿到的数据，汇总到一个 MySQL 实例的一个表中，然后在这个汇总实例上做逻辑操作。**
  上面的查询语句的执行流程为：
  * 在汇总库上创建一个临时表temp_t，表里包含三个字段v，k，t_modified；
  * 在各个分库上分别执行；

    ```sql
    select v,k,t_modified from t where k >= M order by t_modified desc limit 100;
    ```

  * 把分库执行的结果插入到 temp_t 表中；
  * 最后再执行`select v from temp_t order by t_modified desc limit 100;`得到结果。

## 为什么临时表可以重名

对于不同线程可以创建同名的临时表，这是怎么做到的呢？

在创建临时表时，MySQL 要给这个临时表创建一个文件保存表结构定义，还要有地方保存表数据。

表结构文件放在临时文件目录下，文件名的后缀是根据引擎不同处理不同（MyISAM后缀：MYI，innodb后缀：frm，Memory后缀：frm），前缀是“#sql{进程 id}\_{线程 id}_ 序列号”。可以使用 select @@tmpdir 命令，来显示实例的临时文件目录。

表中数据的存放方式，在不同的 MySQL 版本中有着不同的处理方式：

* 在 5.6 以及之前的版本里，MySQL 会在临时文件目录下创建一个相同前缀、以.ibd 为后缀的文件，用来存放数据文件；
* 从 5.7 版本开始，MySQL 引入了一个临时文件表空间，专门用来存放临时文件的数据。不需要再创建 ibd 文件。

MySQL 维护数据表，除了物理上要有文件外，内存里面也有一套机制区别不同的表，每个表都对应一个 table_def_key。

* 一个普通表的 table_def_key 的值是由“库名 + 表名”得到的，所以如果在同一个库下创建两个同名的普通表，创建第二个表的过程中就会发现 table_def_key 已经存在了。
* 而对于临时表，table_def_key 在“库名 + 表名”基础上，又加入了“server_id+thread_id”。所以两个不同的session创建同名的临时表table_def_key不会相同，可以并存。

在实现上，每个线程都维护了自己的临时表链表。这样每次 session 内操作表的时候，先遍历链表，检查是否有这个名字的临时表，如果有就优先操作临时表，如果没有再操作普通表；在 session 结束的时候，对链表里的每个临时表，执行 “DROP TEMPORARY TABLE + 表名”操作。

## 临时表和主备复制

在binlog_format=statment/mixed 的时候，binlog需要记录临时表的创建删除等操作，如果临时表的操作都不记录，那么在语句中使用到临时表的地方在备库执行会报错“表 temp_t 不存在”

在binlog_format=row时，那么跟临时表有关的语句，就不会记录到 binlog 里。因为row格式下，更新插入等操作记录的具体的值。

MySQL 在记录 binlog 的时候，不论是 create table 还是 alter table 语句，都是原样记录，甚至于连空格都不变。但是如果执行 drop table t_normal，系统记录 binlog 就会写成：

```sql
DROP TABLE `t_normal` /* generated by server */
```

原因：drop table 命令是可以一次删除多个表的。例如设置 binlog_format=row，如果主库上执行 "drop table t_normal, temp_t"这个命令，那么 binlog 中就只能记录：

```sql
DROP TABLE `t_normal` /* generated by server */
```

因为备库上并没有表temp_t，将这个命令重写后再传到备库执行，才不会导致备库同步线程停止。所以，drop table 命令记录 binlog 的时候，就必须对语句做改写。“/* generated by server */”说明了这是一个被服务端改写过的命令。

**主备复制的另一个问题：主库上不同的线程创建同名的临时表是没关系的，但是传到备库执行是怎么处理的呢？**

主库 M 上的两个 session 创建了同名的临时表 t1，这两个 create temporary table t1 语句都会被传到备库 S 上。但是，备库的应用日志线程是共用的，也就是说要在应用线程里面先后执行这个 create 语句两次。（即使开了多线程复制，也可能被分配到从库的同一个 worker 中执行）。那么，这会不会导致同步线程报错 ？

MySQL 在记录 binlog 的时候，会把主库执行这个语句的线程 id 写到 binlog 中。这样，在备库的应用线程就能够知道执行每个语句的主库线程 id，并利用这个线程 id 来构造临时表的 table_def_key：临时表 t1，在备库的 table_def_key 就是：库名 +t1+“M 的 serverid”+“session A 的 thread_id”;因此table_def_key会不同，所以这两个表在备库的应用线程里面是不会冲突的。
