# MySQL kill命令

MySQL的kill命令分两种，一个是kill query + 线程id，表示终止这个线程中正在执行的语句；一个是kil connection + 线程id，这里connection可缺省，表示断开这个线程的连接，如果这个线程有语句正在执行，要先停止正在执行的语句。

## kill query

在执行一个查询语句的过程中，想要放弃查询可以使用kill query命令终止。

kill命令发出后，线程并不是直接退出，而将对应的session的运行状态改成THD::KILL_QUERY(将变量killed赋值为THD::KILL_QUERY)；再给session的执行线程发送一个信号。

**为什么发送信号**

如果session对应的语句在锁等待中，线程并不能直接受到终止信号，还会继续锁等待，发一个信号的目的，就是让session退出等待，来处理这个THD::KILL_QUERY 状态。

上面的含义是：
1.一个语句执行过程中有多处“埋点”，在这些“埋点”的地方判断线程状态，如果发现线程状态是 THD::KILL_QUERY，才开始进入语句终止逻辑；
2.如果处于等待状态，必须是一个可以被唤醒的等待，否则根本不会执行到“埋点”处；
3.语句从开始进入终止逻辑，到终止逻辑完全完成，是有一个过程的。

## kill connection

kill connection命令发出后，会将线程状态设置KILL_CONNECTION，并关掉线程的网络连接。对应的线程客户端会收到“Lost connection to MySQL server during query”（断开连接）提示。后面的执行流程和kill query的一致。

##  kill 不掉的情况

现象：一个session虽然执行了kill query命令但是没有什么效果，执行完kill connection命令后，才断开session连接，提示“Lost connection to MySQL server during query”。这时候通过show processlist看到之前session的`Command`显示为`Killed`。

* 原因1：线程没有执行到判断线程状态的逻辑。

    当当前执行查询的线程达到`innodb_thread_concurrency`且一直没有空余线程时，新进来的session C就会一直在等待，在实现上，等行锁时，是使用 pthread_cond_timedwait 函数，这个等待状态可以被唤醒。但是session C还没有进入InnoDB，它的等待逻辑是：每 10 毫秒判断一下是否可以进入 InnoDB 执行，如果不行，就调用 nanosleep 函数进入 sleep 状态。所以kill query命名会没有效果，因为session C不会去判断线程的状态。而kill connection命令会把session C线程状态设置为 KILL_CONNECTION，再断开session C的网络连接。

    show processlist一个特别的逻辑：如果一个线程的状态是 KILL_CONNECTION，就把 Command 列显示成 Killed。

* 原因2：终止逻辑耗时较长

    这时候，从 show processlist 结果上看也是 Command=Killed，需要等到终止逻辑完成，语句才算真正完成。这类情况，比较常见的场景有以下几种：
    * 超大事务执行期间被 kill。这时候，回滚操作需要对事务执行期间生成的所有新数据版本做回收操作，耗时很长。
    * 大查询回滚。如果查询过程中生成了比较大的临时文件，加上此时文件系统压力大，删除临时文件可能需要等待 IO 资源，导致耗时较长。
    * DDL 命令执行到最后阶段，如果被 kill，需要删除中间过程的临时文件，也可能受 IO 资源影响耗时较久。

**如何让Killed状态尽快结束**

如果是InnoDB 并发度的问题，可以临时调大 innodb_thread_concurrency 的值，或者停掉别的线程，让出位子给这个线程执行。

而如果是回滚逻辑由于受到 IO 资源限制执行得比较慢，就通过减少系统压力让它加速。

做完这些操作后，只能等待流程自己完成。

## 关于客户端的误解

**直接在客户端通过 Ctrl+C 命令，是不是就可以直接终止线程呢？** 

不可以。由于 MySQL 是停等协议，所以这个线程执行的语句还没有返回的时候，再往这个连接里面继续发命令也是没有用的。实际上，执行 Ctrl+C 的时候，是 MySQL 客户端另外启动一个连接，然后发送一个 kill query 命令。

**如果库里面的表特别多，连接就会很慢。**

每个客户端在和服务端建立连接的时候，需要做的事情就是 TCP 握手、用户校验、获取权限。这几个操作，显然跟库里面表的个数无关。当使用默认参数连接的时候，MySQL 客户端会提供一个本地库名和表名补全的功能。为了实现这个功能，客户端在连接成功后，需要多做一些操作：

1.执行 show databases；
2.切到 db1 库，执行 show tables；
3.把这两个命令的结果用于构建一个本地的哈希表。

在上面这些操作中最花时间就是第三部在构建哈希表的操作，所以当一个库中表的个数非常多的时候，就会比较慢。在连接命令中加上 -A，就可以关掉这个自动补全的功能，然后客户端就可以快速返回了。

除了加上-A以外，加-quick（或者简写为-q）参数，也可以跳过这个阶段。

需要注意的是MySQL 客户端发送请求后，接收服务端返回结果的方式有两种：一种是本地缓存，也就是在本地开一片内存，先把结果存起来。如果用 API 开发，对应的就是 mysql_store_result 方法。另一种是不缓存，读一个处理一个。如果用 API 开发，对应的就是 mysql_use_result 方法。MySQL 客户端默认采用第一种方式，而如果加上–quick 参数，就会使用第二种不缓存的方式。采用不缓存的方式时，如果本地处理得慢，就会导致服务端发送结果被阻塞，因此会让服务端变慢。

为什么要给这个参数取名叫作 quick 呢？这是因为使用这个参数可以达到以下三点效果：
* 跳过表名自动补全功能；
* mysql_store_result 需要申请本地内存来缓存查询结果，如果查询结果太大，会耗费较多的本地内存，可能会影响客户端本地机器的性能；
* 是不会把执行命令记录到本地的命令历史文件。

所以-quick参数的意思是让客户端变得更快。


