# count(*)的实现方式和优化

## count(*) 的实现方式

不同的MySQL引擎中，count(*)的实现方式不同。

* MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数据，效率很高。
* InnoDB引擎比较麻烦，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。

当count(*)加上where条件时，MyISAM的实现与InnoDB一致。

**为什么InnoDB不能像MyISAM一样把count的数据存储起来？**

因为MVCC（多版本并发控制）的原因，InnoDB无法准确确定当前查询所在的事务应该返回多少行合适，必须要累积计数。

InnoDB也在count(\*)时做了优化，InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于 count(*) 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL 优化器会找到最小的那棵树来遍历。**在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。**

`show table status`：输出的结果中的Rows不能代表当前表的实际行数，因为索引统计的值是通过采样来估算的。Rows 也是从这个采样估算得来的。**官方文档说误差可能达到 40% 到 50%**

## 优化count的方式

### 用缓存系统保存计数

通过使用Redis缓存表的行数。

问题：
* 一致性问题，redis异常重启了，数据插入成功了但是redis计数没有加1。
    解决：Redis 异常重启以后，到数据库里面单独执行一次 count(*) 获取真实的行数，再把这个值写回到 Redis 里
* 逻辑上不精确，对于MVCC，一个事务A插入数据后redis计数加1，事务未提交，但是另一个事务B实际上读取不到事务A插入的数据，但是redis里的计数已经加1了。

### 在数据库保存计数

将计数的数据保存在数据库一张表中，可以解决崩溃一致性问题，和逻辑上不精确问题。注意表使用InnoDB引擎。**更新计数表涉及到行锁的竞争，先插入再更新能最大程度地减少了事务之间的锁等待，提升了并发度。**

**注意**

在数据库中保存计数可能也会出现数据逻辑不准确的问题。

```sql
--  会话A                会话B
    begin;
    插入一行数据R;
                        begin;
                        插入一行数据R;
                        计数表中计数值+1;
                        commit;
    计数表中计数值+1;
    查询计数表中行数;
    commit;
```

在会话A中最后查询计数时会出现逻辑上不准确的情况，因为会话B已经提交了计数值得修改，所以会话A在更新计数后会查询到最新的计数值，但是却查不到会话B插入的数据。可先更新计数值后插入数据，但是这样在大批量插入操作会导致计数表锁等待很多，可能产生性能影响。

```sql
--  会话A                会话B
    begin;
    计数表中计数值+1;
    插入一行数据R;
                        begin;
    commit;             计数表中计数值+1;
                        插入一行数据R;
                        查询计数表中行数;
                        commit;
```

这样修改后，会话B计数值+1需要等待会话A提交后释放计数表上的锁，之后会话B能查到最新的计数值，但是查询不到会话A插入的数据吗？？？？

最好的方式是不是在需要插入之后查询计数表行数的时候先查询一下，直接+1当做行数返回？？？？

## 不同的count用法的性能差异（InnoDB）

count(*) count(主键ID) count(字段) count(1)等不同用法。

count()的语义：count()是一个聚合函数，对于返回的结果集，一行一行地判断，如果count函数的参数不是NULL，累计值就加 1，否则不加。最后返回累计值。

所以，count(*)、count(主键ID) 和 count(1) 都表示返回满足条件的结果集的总行数；而 count(字段），则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。

分析性能差异的时候的原则：
1.server 层要什么就给什么；
2.InnoDB 只给必要的值；
3.现在的优化器只优化了 count(*) 的语义为“取行数”，其他“显而易见”的优化并没有做。

* **对于 count(主键ID)来说**,InnoDB 引擎会遍历整张表，把每一行的 ID 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。
* **对于count(1)来说**，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。这会比count(主键ID)快，因为从引擎返回 ID 会涉及到解析数据行，以及拷贝字段值的操作。
* **对于 count(字段) 来说：**
    * 如果这个字段定义为not null，一行行地从记录里面读出这个字段，判断不能为null，按行累加；
    * 如果这个字段定义为可以为null，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。
    * 如果字段上没有索引，就只能选主键索引
* **对于count(\*)**，前面说过并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。

**按照效率排序的话，count(字段)<count(主键 id)<count(1)≈count(\*)，所以尽量使用 count(\*)。**

**如果某表上有count比较多的操作,最好是用count(1)或者count(\*),然后选择一列占用字节数最少的建立索引(比如tinyint类型)。**