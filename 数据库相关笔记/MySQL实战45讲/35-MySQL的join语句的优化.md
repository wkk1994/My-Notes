# MySQL的join语句的优化

## Multi-Range Read 优化

这个优化的主要目的是尽量使用顺序读盘。 InnoDB 的索引结构存在“回表”行为，因为主键索引是一棵 B+ 树，在这棵树上，每次只能根据一个主键 id 查到一行数据。因此，回表肯定是一行行搜索主键索引的。如果查询的普通索引是递增顺序的，回表的id值就可能是随机的，就会出现随机访问，性能相对比较差。如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。

**这就是MRR优化的设计思路。**

优化后查询的执行过程：
* 1.根据索引 a，定位到满足条件的记录，将 id 值放入 read_rnd_buffer 中 ;
* 2.将read_rnd_buffer中的id进行递增排序；
* 3.排序后的id数组，依次到主键id索引中查记录，并作为结果返回。

`read_rnd_bugger`的大小由参数`read_rnd_buffer_size`控制。如果步骤1中的`read_rnd_buffer`放满了，就会先执行完2，3，然后清空`read_rnd_buffer`。之后继续索引a的下个记录，并继续循环。

想要稳定地使用 MRR 优化的话，需要设置set optimizer_switch="mrr_cost_based=off"。（官方文档的说法，是现在的优化器策略，判断消耗的时候，会更倾向于不使用 MRR，把 mrr_cost_based 设置为 off，就是固定使用 MRR 了。）

从explain结果中查看Extra字段多了"Using MRR"，表示的是用上了MRR优化。而且由于使用了MRR，最后得到的结果集也是按照主键id递增的。

**MRR 能够提升性能的核心**在于，这条查询语句在索引 a 上做的是一个范围查询（也就是说，这是一个多值查询），可以得到足够多的主键 id。这样通过排序以后，再去主键索引查数据，才能体现出“顺序性”的优势。

## Batched Key Access

MySQL 在 5.6 版本后开始引入的 Batched Key Access(BKA) 算法了。这个 BKA 算法，其实就是对 NLJ 算法的优化。

BKA 算法的逻辑是：从驱动表t1中取出来的数据先放在join_buffer中，进行排序后再到被驱动表中进行查询。尽量避免随机访问。

使用BKA优化算法，之前先设置"set optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on';"

## BNL 算法的性能问题

使用 Block Nested-Loop Join(BNL) 算法时，可能会对被驱动表做多次扫描。如果这个被驱动表是一个大的冷数据表，除了会导致 IO 压力大以外，还会产生的影响：
* 如果一个使用 BNL 算法的 join 语句，多次扫描一个冷表，而且这个语句执行时间超过 1 秒，就会在再次扫描冷表的时候，把冷表的数据页移到 LRU 链表头部。这种情况对应的，是冷表的数据量小于整个 Buffer Pool 的 3/8，能够完全放入 old 区域的情况。
* 如果这个冷表很大，就会出现另外一种情况：业务正常访问的数据页，没有机会进入 young 区域。一个正常访问的数据页，要进入young区域，需要隔1秒后再次被访问到。但是由于大表join语句在循环读磁盘和淘汰内存页，进入old区域的数据很可能在1秒之内就被淘汰了，没有机会进入young区域。

**大表 join 操作虽然对 IO 有影响，但是在语句执行结束后，对 IO 的影响也就结束了。但是，对 Buffer Pool 的影响就是持续性的，需要依靠后续的查询请求慢慢恢复内存命中率。** 为了减少这种影响，可以考虑增大 join_buffer_size 的值，减少对被驱动表的扫描次数。

BNL 算法对系统的影响主要包括三个方面：
* 可能会多次扫描被驱动表，占用磁盘 IO 资源；
* 判断 join 条件需要执行 M*N 次对比（M、N 分别是两张表的行数），如果是大表就会占用非常多的 CPU 资源；
* 可能会导致 Buffer Pool 的热数据被淘汰，影响内存命中率。

## BNL 转 BKA

一般情况下可以在被驱动表上直接创建索引，这时就可以直接转成BKA算法了。但是有些时候，会不适合创建索引。如:

```sql
select * from t1 join t2 on (t1.b=t2.b) where t2.b>=1 and t2.b<=2000;
```

t2表中数据量比较大，但是使用到的数据确只是2000行。如果这个语句同时是一个低频语句，为了这么一个查询语句维护一个索引比较浪费空间。同时t2表的数据量比较大，在循环判断次数也比较多。

这种情况可以考虑使用临时表进行优化。思路：
* 1.把表t2中满足条件的数据放在临时表temp_t中；
* 2.为了让join使用BKA算法，给临时表temp_t的join字段b加上索引；
* 3.让表t1和temp_t做join操作。

对于的sql语句：

```sql
create temporary table temp_t(id int primary key, a int, b int, index(b))engine=innodb;
insert into temp_t select * from t2 where b>=1 and b<=2000;
select * from t1 join temp_t on (t1.b=temp_t.b);
```

这样做的优化主要是优化在后续join查询，向临时表插入数据也会对字段b进行全表扫描，对于表数据越多，查询值范围越小的查询语句效果越好。

## 扩展 -hash join

上面计算10亿次的操作，如果join_buffer里面维护的不是一个无序数组，而是一个哈希表，那么久不需要10亿次判断，而是100万次hash查找。这样的话速度会快很多。这也正是 MySQL 的优化器和执行器一直被诟病的一个原因：不支持哈希 join。并且，MySQL 官方的 roadmap，也是迟迟没有把这个优化排上议程。

这个优化思路，可以自己实现在业务端。实现流程大致如下：

* 1.select * from t1;取得表 t1 的全部 1000 行数据，在业务端存入一个 hash 结构；
* 2.select * from t2 where b>=1 and b<=2000; 获取表 t2 中满足条件的 2000 行数据。
* 3.把这 2000 行数据，一行一行地取到业务端，到 hash 结构的数据表中寻找匹配的数据。满足匹配的条件的这行数据，就作为结果集的一行。

理论上，这个过程会比临时表方案的执行速度还要快一些。

## 优化方法的总结

* BKA 优化是 MySQL 已经内置支持的，建议默认使用；
* BNL 算法效率低，建议都尽量转成 BKA 算法。优化的方向就是给被驱动表的关联字段加上索引；
* 基于临时表的改进方案，对于能够提前过滤出小数据的 join 语句来说，效果还是很好的；
* MySQL 目前的版本还不支持 hash join，但可以配合应用端自己模拟出来，理论上效果要好于临时表的方案。




















