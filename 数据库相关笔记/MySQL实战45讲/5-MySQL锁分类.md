# MySQL全局锁，表级锁和行锁

## 全局锁

全局锁是对整个数据库实例加锁。MySQL加全局读锁的方式`Flush tables with read lock`（FTWRL）。使用这个命令后其他线程的以下语句会被阻塞：数据库更新语句（数据的增删改）、数据定义语句（建表，修改表结构等）和更新类事务的提交语句。

* 使用范围

    做全库的备份，在备份过程中整个库完全处于只读状态。可以保证备份的数据业务逻辑一致性。

* 局限性

    如果在主库上备份，那么备份期间都不能执行更新，业务基本上停止。
    如果在从库上备份，那么备份期间都不能执行主库同步过来的binlog，会导致主从延迟。

* 加锁语句

    ```sql
    flush tables with read lock;
    ```
### mysqldump

官方自带的逻辑备份工具。当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。

**注意：**

single-transaction 方法只适用于所有的表使用事务引擎的库。如果有的表使用了不支持事务的引擎，那么备份就只能通过 FTWRL 方法。

### set global readonly=true

`set global readonly=true`可以让全库只读，也可以进行数据库备份，但是：


* 在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，我不建议你使用。

* 在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。

**注意：**`set global readonly=true`只读模式，限定的是普通用户进行数据修改的操作，但不会限定具有super权限的用户的数据修改操作 (但是如果设置了"super_read_only=true"， 则就会限定具有super权限的用户的数据修改操作了)；在MySQL中设置read_only=true后，普通的应用用户进行insert、update、delete等会产生数据变化的DML操作时，都会报出数据库处于只读模式不能发生数据变化的错误，但具有super权限的用户，例如在本地或远程通过root用户登录到数据库，还是可以进行数据变化的DML操作；(也就是说"real_only"只会禁止普通用户权限的mysql写操作，不能限制super权限用户的写操作； 如果要想连super权限用户的写操作也禁止，就使用"flush tables with read lock;"，这样设置也会阻止主从同步复制！)

## 表级锁

MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。

### 表锁

表锁的语法是 lock tables … read/write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

例如：在某个线程中执行 lock tables t1 read, t2 write; 则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。

### MDL（metadata lock)锁

MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。

* 读锁之间不互斥，可以有多个线程同时对一张表增删改查。
* 读写锁之间，写锁之间互斥，用来保证变更表结构操作的安全性。两个线程同时对一个表结构做变更时，必须要等其中一个执行完，另一个才能执行。

给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操作的时候，你肯定会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也会出问题。

例如：
 
    sessionA 先启动，会对表t加一个MDL读锁，sessionB 也需要表t的MDL读锁，所以可以正常执行。
    sessionC 要修改表t的结构，需要MDL写锁会被阻塞，但是后面的sessionD 也需要表t的MDL读锁，会被阻塞，这个表象就是表t完全不可读了。
    如果表t上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。
    并且事务中的DML锁，只会等到事务提交后再释放。

**如何安全地给小表加字段？**

* 解决长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的 information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。
* 要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，kill 可能未必管用。比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。

## 行锁

MySQL的行锁时在引擎层由各个引擎自己实现的。但并不是所有引擎都支持行锁。（MyISAM不支持）。

在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。

**注意：**

* 因为行锁在事务提交时才会释放，应当把最容易发送锁等待的数据放在最后操作
* innodb行级锁是通过锁索引记录实现的。如果update的列没建索引，即使只update一条记录也会锁定整张表。

### 死锁和死锁检测

当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。

出现死锁的解决策略：

* 直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置（默认50s）。设置过小可能导致误杀。
* 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。如果并发线程很多，都是操作同一行，死锁检测要耗费大量的 CPU 资源。

**怎么解决由这种热点行更新导致的性能问题呢？**

* 确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。可能出现大量超时的业务。
* 控制并发，控制热点行的最多并发线程。
* 将一行改成逻辑上的多行来减少锁冲突。以影院账户为例，可以考虑放在多条记录上，比如 10 个记录，影院的账户总额等于这 10 个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的 1/10，可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗。但是遇到账户余额减的就有问题。

## 问题

**mysql 5.6是支持online ddl，执行流程**

* 1.拿MDL写锁
* 2.DDL执行准备
* 3.降级成MDL读锁
* 4.DDL核心执行（耗时最多的）
* 5.升级成MDL写锁
* 6.DDL最终提交
* 7.释放MDL锁

1、2、3、5、6、7如果没有锁冲突，执行时间非常短。第4步占用了DDL绝大部分时间，这期间这个表可以正常读写数据，是因此称为“online ”。

**当备库用–single-transaction 做逻辑备份的时候，如果从主库的 binlog 传来一个 DDL 语句会怎么样？**

假设这个 DDL 是针对表 t1 的， 备份过程中几个关键的语句列出来：

```sql
Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
Q2:START TRANSACTION  WITH CONSISTENT SNAPSHOT；
/* other tables *
/Q3:SAVEPOINT sp;
/* 时刻 1 */
Q4:show create table `t1`;
/* 时刻 2 */
Q5:SELECT * FROM `t1`;
/* 时刻 3 */
Q6:ROLLBACK TO SAVEPOINT sp;
/* 时刻 4 */
/* other tables */
```

在备份开始的时候，为了确保 RR（可重复读）隔离级别，再设置一次 RR 隔离级别 (Q1);启动事务，这里用 WITH CONSISTENT SNAPSHOT 确保这个语句执行完就可以得到一个一致性视图（Q2)；设置一个保存点，这个很重要（Q3）；show create 是为了拿到表结构 (Q4)，然后正式导数据 （Q5），回滚到 SAVEPOINT sp，在这里的作用是释放 t1 的 MDL 锁 （Q6）。

DDL 从主库传过来的时间按照效果不同，分为四个时刻。

* 如果在 Q4 语句执行之前到达，现象：没有影响，备份拿到的是 DDL 后的表结构。
* 如果在“时刻 2”到达，则表结构被改过，Q5 执行的时候，报 Table definition has changed, please retry transaction，现象：mysqldump 终止；
* 如果在“时刻 2”和“时刻 3”之间到达，mysqldump 占着 t1 的 MDL 读锁，binlog 被阻塞，现象：主从延迟，直到 Q6 执行完成。
* 从“时刻 4”开始，mysqldump 释放了 MDL 读锁，现象：没有影响，备份拿到的是 DDL 前的表结构。