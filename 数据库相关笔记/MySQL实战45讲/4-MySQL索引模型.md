# MySQL索引

为了提高数据查询的效率

常见索引模型有三种：哈希表、有序数组、搜索树

**对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。**

## 哈希表（hash index）

哈希表是一种以键 - 值（key-value）存储数据的结构，当多个key经过哈希函数的换算，出现相同时，value就会拉出一个链表。mysql中只有memory引擎显式支持哈希索引，innodb是隐式支持哈希索引的。

使用哈希表实现的索引称为哈希索引。

**适用范围和局限**：

* 哈希索引只适用于等值查询，包括=，in(),<=>，不支持任何范围查询。例如where price>100。
* 哈希索引只包含哈希值和行指针，不存储字段值，所以不能使用"覆盖索引"的优化方式，去避免读取数据表。
* 哈希索引数据不是按照索引值顺序存储的，所以索引无法用于排序（Order By）。
* 如果哈希冲突很多（不同的索引列值却有相同的哈希值）的话，一些索引维护操作的代价也会很高。
* 使用多列作为一个哈希索引的话，它不支持部分索引列匹配查找，因为哈希索引始终使用索引列的全部内容计算哈希值。

**注意**：

innodb引擎有一个特殊的功能“自适应哈希索引”，当innodb注意到一些索引值被使用的非常频繁时，且符合哈希特点（如每次查询的列都一样），它会在内存中基于B-Tree索引之上再创建一个哈希索引。这是一个完全自动的，内部行为。

## 有序数组

按照给定的顺序排好序的数组。

**适用范围和局限**：

* 等值查询和比较查询性能非常优秀，但是更新数据很繁琐，如果在中间添加数据需要移动所有的后面的数据。
* 有序数组索引只适用于静态存储引擎，比如某学期学生成绩。

## 搜索树

最简单的是二叉搜索树，然后有平衡二叉树、B树（B-Tree）和B+树（B+Tree）等。存储引擎MyISAM和InnoDB都支持 B+树 索引。

![二叉搜索树示意图](../../../../youdaonote-images/51F1C08E6EC543CD86F9019A725C4AB4.png)

二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -> UserC -> UserF -> User2 这个路径得到。这个时间复杂度是 O($log_2N$)。为了维持 O($log_2N$) 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 O($log_2N$)。

## InnoDB存储引擎中的索引

当数据量很大的时候，树就会越高，每次查询需要的磁盘IO次数就多。在机械硬盘的时代，从磁盘中随机读取一个数据块非常慢，磁盘IO次数越多查询就会越慢。所以InnoDB使用B+树的模型存储索引，一个子节点内存放的键数目取决于数据块的大小，以 InnoDB 的一个整数字段索引为例，这个数量差不多是 1200。当树高为4的时候就可以存 1200 的 3 次方个值，这已经 17 亿了。基本满足的单表的数据大小。
在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。InnoDB索引分为：主键索引（聚簇索引/聚集索引 clustered index）和非主键索引（二级索引 secondary index）。表中没有主键则将唯一字段认作主键，若没有唯一字段则InnoDB引擎会自己创建一个隐藏的主键，但是这个主键对Server层是透明的，优化器用不上。

主键索引的叶子节点存的是整行数据。非主键索引的叶子节点的内容是主键的值。所以非主键索引查询需要先查询到主键的值，再去主键索引里查询行数据。这一过程称为`回表`，基于非主键索引的查询需要多扫描一棵索引树。在应用中应尽量使用主键查询，或者使用普通查询时直接只查询主键防止`回表`。

主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。

### 索引维护

B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。

* 数据的插入与删除
    &nbsp;
    插入数据的时候可能是直接插入或者需要将部分数据往后挪空出位置再插入。
    &nbsp;
    特殊情况：如果插入已经满了的数据页，则需要新申请一个数据页，然后将满的数据页的部分数据挪过去，最后再进行插入。（这个过程被称为页分裂）。这样做除了性能受影响外，页分裂操作还影响数据页的利用率。
    &nbsp;
    如果插入的数据是向某个满数据页的首或者尾插入，为了减少页分裂和数据移动，会先看与这个满数据页相邻的前后数据页是否也已经满了，如果未满则会将该待插入数据先放置到前或后的数据页，满才会进行页分裂。（这样做是为了增加空间利用率）
    &nbsp;
    同样，由于相邻两页删除了部分数据，两页的空间利用率都变得很低，会将这两数据页进行合并。（这个歌过程被称为页合并）

### 覆盖索引

如果查询语句只返回当前表的主键，这样根据普通索引查询直接就可以获得到主键值，不需要`回表`。也就是说在这个查询里面，普通索引已经`覆盖了`查询需求，称为覆盖索引。

如：`select ID from T where k between 3 and 5`，查询ID为主键，普通索引k已经覆盖了查询需求。

**由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。**

需要注意的是，在引擎内部使用覆盖索引在索引 k 上其实读了三个记录，R3~R5（对应的索引 k 上的记录项），但是对于 MySQL 的 Server 层来说，它就是找引擎拿到了两条记录，因此 MySQL 认为扫描行数是 2。

### 最左前缀原则

联合索引的最左N个字段，或者字符串索引的前N个字符。都会使用这个联合索引检索。

B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。

如： 建立(name, age)这个联合索引。 查询语句" where name like '张%' "，也会用上这个索引。不只是索引的全部定义，只要满足最左前缀，就可以利用索引加速检索。

#### **在建立联合索引的时候，如何安排索引内的字段顺序？**

* 索引的复用能力: 当存在(a,b)这个联合索引后，一般就不需要在a上建立索引了。因此第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。

* 索引的占用空间：比如name 字段是比 age 字段大的 ，那么就建议创建一个（name,age) 的联合索引和一个 (age) 的单字段索引。

### 索引下推

对于联合索引，使用最左前缀原则进行匹配后，如果联合索引的其他字段在where条件中，在MySQL5.6之前，只能回表，再进行其他字段的条件判断。MySQL5.6之后引入索引下推优化（index condition pushdown)，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

如：联合索引(name, age)，查询语句" where name like '张 %' and age=10 "，根据最左前缀name匹配后，再判断age是否匹配，匹配再回表，不匹配直接跳过。减少回表次数。

## 参考

* [MySQL索引初探](https://www.cnblogs.com/ChangAn223/p/10747425.html)
* [MYSQL索引](https://www.cnblogs.com/Aiapple/p/5693239.html)