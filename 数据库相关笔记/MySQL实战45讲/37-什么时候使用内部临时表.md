# 什么时候使用内部临时表

 sort buffer、内存临时表和 join buffer，这三个数据结构都是用来存放语句执行过程中的中间数据，以辅助 SQL 语句的执行的。排序的时候用到了 sort buffer，在使用 join 语句的时候用到了 join buffer。什么时候会用到内部临时表？

## union执行流程

```sql
(select 1000 as f) union (select id from t1 order by id desc limit 2);
```

上面语句的语义是取这两个子查询结果的并集。并集的意思就是这两个集合加起来，重复的行只保留一行。使用explain可以看到：

第三行的 Extra 字段，表示在对子查询的结果集做 union 的时候，使用了临时表 (Using temporary)。

上面语句的执行流程：

* 1.创建一个内部临时表，这个临时表只有一个整形字段f，并且f是主键字段。
* 2.执行第一个子查询，得到1000这个值，并且存入临时表中。
* 3.执行第二个子查询：
  * 拿到第一行id=1000，试图插入临时表中。但由于 1000 这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行；
  * 取到第二行 id=999，插入临时表成功。
* 从临时表中按行取出数据，返回结果，并删除临时表，结果中包含两行数据分别是 1000 和 999。

这里的内存临时表起到了暂存数据的作用，而且计算过程还用上了临时表主键 id 的唯一性约束，实现了 union 的语义。

如果union改成union all的话，就没有去重的语义。这样执行的时候，就依次执行子查询，得到的结果直接作为结果集的一部分，发给客户端。因此就不需要临时表了。

## group by 执行流程

```sql
select id%10 as m, count(*) as c from t1 group by m;
```

这个语句的逻辑是把表 t1 里的数据，按照 id%10 进行分组统计，并按照 m 的结果排序后输出。它的 explain 结果 Extra 字段里面：

* Using index，表示这个语句使用了覆盖索引，选择了索引 a，不需要回表；
* Using temporary，表示使用了临时表；
* Using filesort，表示需要排序。

上面语句的执行流程：

* 1.创建内存临时表，表里有两个字段 m 和 c，主键是 m；
* 2.扫描表 t1 的索引 a，依次取出叶子节点上的 id 值，计算 id%10 的结果，记为 x；
  * 如果临时表中没有主键为 x 的行，就插入一个记录 (x,1);
  * 如果表中有主键为 x 的行，就将 x 这一行的 c 值加 1；
* 3.遍历完成后，再根据字段 m 做排序，得到结果集返回给客户端。

如果不需要排序，可以在末尾添加order by null。

**参数`tmp_table_size`** 控制内存临时表的大小，默认是 16M。当内存临时表不够大时，会把内存临时表转成磁盘临时表，磁盘临时表默认使用的引擎是 InnoDB。如果这个表 t1 的数据量很大，很可能这个查询需要的磁盘临时表就会占用大量的磁盘空间。

### group by 优化方法 -- 索引

不论是使用内存临时表还是磁盘临时表，group by 逻辑都需要构造一个带唯一索引的表，执行代价都是比较高的。如果表的数据量比较大，上面这个 group by 语句执行起来就会很慢。

优化方式：group by的数据是索引，这样通过扫描索引就可以快速得到结果。

在 MySQL 5.7 版本支持了 generated column 机制，用来实现列数据的关联更新。你可以用下面的方法创建一个列 z，然后在 z 列上创建一个索引：

```sql
alter table t1 add column z int generated always as(id % 100), add index(z);
```

新的查询语句为：

```sql
select z, count(*) as c from t1 group by z;
```

### group by 优化方法 -- 直接排序

如果遇到不适合创建索引的情况，可以通过直接让group by走磁盘临时表的方法。

在group by语句中加入SQL_BIG_RESULT加入这个提示（hint），可以告诉优化器，这个语句涉及的数据量很大，直接使用磁盘临时表。MySQL优化器发现磁盘临时表是 B+ 树存储，存储效率不如数组来得高。所以，从磁盘空间考虑，会直接用数组来存。

```sql
select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m;
```

执行流程为：

* 1.初始化sort_buffer，确定放入一个整形字段，记为m；
* 2.扫描表t1的索引a，依次取出里面的id值，将id%100的值存入sort_buffer中；
* 3.扫描完成后，对 sort_buffer 的字段 m 做排序（如果 sort_buffer 内存不够用，就会利用磁盘临时文件辅助排序）；
* 4.排序完成后，就得到了一个有序数组。

根据有序数组，得到数组里面的不同值，以及每个值的出现次数。

explain结果Extra字段可以看到“Using index;Using filesort”。

**MySQL 什么时候会使用内部临时表？**

1.如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果；
2.join_buffer 是无序数组，sort_buffer 是有序数组，临时表是二维表结构；
3.如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。比如例子中，union 需要用到唯一索引约束， group by 还需要用到另外一个字段来存累积计数。

## 总结

* 如果对 group by 语句的结果没有排序要求，要在语句后面加 order by null；
* 尽量让 group by 过程用上表的索引，确认方法是 explain 结果里没有 Using temporary 和 Using filesort；
* 如果 group by 需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大 tmp_table_size 参数，来避免用到磁盘临时表；
* 如果数据量实在太大，使用 SQL_BIG_RESULT 这个提示，来告诉优化器直接使用排序算法得到 group by 的结果。
