# 25-MySQL的高可用

## 主备延迟

主备切换可能是一个主动运维动作，比如软件升级、主库所在的机器按计划下线等；也可以是一个被动操作，比如主库所在的机器断电。

在主库A执行完成一个事务，写入binlog，这个时刻记为T1；备库接收完这个binlog的时刻记为T2；备库执行完成这个事务的时刻记为T3。所谓主备延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，就是T3-T1。

在备库上执行`show slave status`命令，返回结果里面会显示`seconds_behind_master`，用于表示当前备库延迟了多少秒。

主备库机器的系统时间设置不一致，不会导致主备延迟的值不准。备库在连接到主库的时候（是在连接到的时候，只是获取一次，后面主库修改时间不会记录到的），会获取当前主库的系统时间 。如果这时候发现主库的系统时间与自己不一致，备库在执行 seconds_behind_master 计算的时候会自动扣掉这个差值。

T2-T1表示的是主备之间的网络状态，在网络正常的时候，这个值很小。所以在网络正常的情况下，主备延迟主要来源是备库接收完binlog和执行完这个事务之间的时间差。一般主备延迟大于1秒就不好了。

### 主备延迟的来源

* 备库所在机器的性能要比主库所在的机器性能差
  因为更新请求对 IOPS 的压力，在主库和备库上是无差别的。所以当备库的机器性能比较差时，就可能会导致主备延迟了。

* 备库压力大
    一般的想法是，既然主库提供了写能力，那么备库可以提供一些读的能力。如果查询压力过大的话就会消耗大量CPU资源，影响了同步速度，造成主备延迟。
    这种情况可以用下面的方式解决：
    * 一主多从。除了备库外，可以多接几个从库，让这些从库来分担读的压力。
    * 通过 binlog 输出到外部系统，比如 Hadoop 这类系统，让外部系统提供统计类查询的能力。  

* 大事务
    如果一个事务过大，在主库上执行需要10分钟，那么传给备库，备库上执行完也需要10分钟，这个大事务很可能导致主备延迟10分钟。所以应该尽量避免大事务的产生，或者把大事务拆分执行。

* 表上无主键的情况
    主库利用索引更改数据,备库回放只能用全表扫描,这种情况可以调整slave_rows_search_algorithms参数适当优化下

### 主备切换的策略

由于主备延迟的存在，所以在主备切换的时候，就相应的有不同的策略。分为可靠性优先策略和可用性优先策略。

#### 可靠性优先策略

可靠性优先策略的目的是降低数据不准确的风险。但是可能会导致系统一段时间不可用。适用于可用性要求不高，允许一段时间系统不可用，对数据可靠性要求比较高的场景。

在双M结构下，主备切换的流程如下：

1.判断备库 B 现在的 seconds_behind_master，如果小于某个值（比如 5 秒）继续下一步，否则持续重试这一步；
2.把主库 A 改成只读状态，即把 readonly 设置为 true；
3.判断备库 B 的 seconds_behind_master 的值，直到这个值变成 0 为止；
4.把备库 B 改成可读写状态，也就是把 readonly 设置为 false；
5.把业务请求切到备库 B。

在这个主备切换过程中，最耗时的过程是步骤3，可能导致系统不可用时间比较长。

#### 可用性优先策略

可用性优先策略的目的是取消系统不可用时间，可能会导致主备数据不一致的情况。可用性优先会把上面的步骤4,5放到最开始执行。适用于可靠性要求不高，但是系统可用性要求很高的场景。


## 备库并行复制能力

如果备库执行日志的速度持续低于主库生成日志的速度，那么主备延迟会越来越大，最后可能达到小时级别。而且对于一个压力持续（并发）比较高的主库来说，备库如果只是单线程执行binlog，很可能永远都追不上主库的节奏。因此备库的并行复制能力很重要。

在官方的 5.6 版本之前，MySQL 只支持单线程复制，由此在主库并发高、TPS 高时就会出现严重的主备延迟问题。

多线程复制机制的基本模式：

![并行模式](../../../../youdaonote-images/FB6A21508D4F48F38928369FECFDD4B0.png)

上图中的`coordinator`就是原来的`sql_thread`，它不再直接更新数据，只负责读取中转日志和分发事务。真正更新日志的，变成了worker线程。work线程的数量由参数`slave_parallel_workers`决定。一般设置为8~16之间最好（对于32核的物理机而言），因为备库还可能提供查询功能。

`coordinator`分发的基本要求：
* 不能造成更新覆盖。更新同一行的两个事务，必须被分发到同一个worker中。
    因为更新同一行的事务如果分发到不同的worker中去，可能造成A更新完成的数据被B更新覆盖。
* 同一个事务不能被拆分，必须放到同一个worker中。
    同一个事务如果被拆分到不同worker中执行，由于执行完成先后的原因语句A的更新会被先看到，而同一个事务中B的更新不会被看到，造成数据不一致的现象。因为不同的worker线程没办法约定一起提交事务，只能各自提交。

### MySQL5.5版本及以前都不支持并行复制
    
    他人实现的按表分发策略，按行分发策略。

### MySQL 5.6 版本的并行复制策略

MySQL5.6版本支持的并行复制策略，只是支持粒度是按库并行。使用与主库上有多个DB，并且压力比较平均的情况。

### MariaDB 的并行复制策略

MariaDB 的并行复制策略利用了组提交的特性：
1.能够在一组里提交的事务，一定不会修改同一行；
2.主库上可以并行执行的事务，备库上也一定可以并行执行。

MariaDB的实现方式：
1. 在一组里面一起提交的事务，有一个相同的 commit_id，下一组就是 commit_id+1；
2. commit_id 直接写到 binlog 里面；
3. 传到备库应用的时候，相同 commit_id 的事务分发到多个 worker 执行；
4. 这一组全部执行完成后，coordinator 再去取下一批。

MariaDB的并行复制策略并不是真正的模拟主库的并发执行方式，因为它只有在同一组事务执行完成的时候才会去执行下一组，而在主库上一组事务还没提交完成的时候，另一些事务已经在执行中了。如果一组事务中出现一个大事务，备库就要等待大事务执行完成才能去执行下一组事务。

### MySQL 5.7 的并行复制策略

在 MariaDB 并行复制实现之后，官方的 MySQL5.7 版本也提供了类似的功能，由参数 slave-parallel-type 来控制并行复制策略：
* 配置为 DATABASE，表示使用 MySQL 5.6 版本的按库并行策略；
* 配置为 LOGICAL_CLOCK，表示的就是类似 MariaDB 的策略。不过，MySQL 5.7 这个策略，针对并行度做了优化。

在MariaDB并行复制中，只有所有你处于commit状态的事务才可以并行。事务处于commit状态，表示已经通过了锁冲突的检验了。在实际上不用等待commit阶段，只要能够到达redo log prepare阶段，就表示事务已经通过锁冲突检验了。

因此，MySQL5.7的并行复制策略是：1.同时处于 prepare 状态的事务，在备库执行时是可以并行的；2.处于 prepare 状态的事务，与处于 commit 状态的事务之间，在备库执行时也是可以并行的。

影响binlog组提交的参数`binlog_group_commit_sync_delay`和`binlog_group_commit_sync_no_delay_count`，适当调整可以制造更多的“同时处于prepare阶段的事务”，这样就增加了备库复制的并行度。

### MySQL 5.7.22 的并行复制策略

MySQL 5.7.22 版本里，MySQL 增加了一个新的并行复制策略，基于 WRITESET 的并行复制。

参数`binlog-transaction-dependency-tracking`用来控制是否启用这个新策略。参数可选值：
* COMMIT_ORDER，表示的就是前面介绍的，根据同时进入 prepare 和 commit 来判断是否可以并行的策略。
* WRITESET，表示的是对于事务涉及更新的每一行，计算出这一行的 hash 值，组成集合 writeset。如果两个事务没有操作相同的行，也就是说它们的 writeset 没有交集，就可以并行。（存在向下兼容性问题，binlog内容要添加hash 值）
* WRITESET_SESSION，是在 WRITESET 的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序。

WRITESET下的唯一标识，这个 hash 值是通过“库名 + 表名 + 索引名 + 值”计算出来的。如果一个表上除了有主键索引外，还有其他唯一索引，那么对于每个唯一索引，insert 语句对应的 writeset 就要多增加一个 hash 值。

writeset的优势：

* writeset 是在主库生成后直接写入到 binlog 里面的，这样在备库执行的时候，不需要解析 binlog 内容（event 里的行数据），节省了很多计算量；
* 不需要把整个事务的 binlog 都扫一遍才能决定分发到哪个 worker，更省内存；
* 由于备库的分发策略不依赖于 binlog 内容，所以 binlog 是 statement 格式也是可以的。

但是对于“表上没主键”和“外键约束”的场景，WRITESET 策略也是没法并行的，也会暂时退化为单线程模型。

**注意：并行复制seconds_behind_master的值计算就不准确了**

## 一主多从的切换正确性

![一主多从基本结构](../../../../youdaonote-images/CF3BD9917F3B48D5AD59B88063541A8F.png)

A 和 A’互为主备， 从库 B、C、D 指向的是主库 A。一主多从的设置，一般用于读写分离，主库负责所有的写入和一部分读，其他的读请求则由从库分担。

当主库A发生故障，主备切换后A’会成为新的主库，从库 B、C、D 也要改接到 A’。正是由于多了从库 B、C、D 重新指向的这个过程，所以主备切换的复杂性也相应增加了。

### 基于位点的主备切换

将节点B设置成节点A’的从库的时候，需要执行一条change master命令：

```sql
CHANGE MASTER TO 
MASTER_HOST=$host_name 
MASTER_PORT=$port 
MASTER_USER=$user_name 
MASTER_PASSWORD=$password 
MASTER_LOG_FILE=$master_log_name 
MASTER_LOG_POS=$master_log_pos
```

* MASTER_HOST、MASTER_PORT、MASTER_USER 和 MASTER_PASSWORD 四个参数，分别代表了主库 A’的 IP、端口、用户名和密码。
* MASTER_LOG_FILE 和 MASTER_LOG_POS 表示，要从主库的 master_log_name 文件的 master_log_pos 这个位置的日志继续同步。而这个位置就是所说的同步位点，也就是主库对应的文件名和日志偏移量。

**怎么确定同步位点？**
原来节点 B 是 A 的从库，本地记录的也是 A 的位点。但是相同的日志，A 的位点和 A’的位点是不同的。因此，从库 B 要切换的时候，就需要先经过“找同步位点”这个逻辑。

可以根据主库A故障的时刻T，通过A’的日志上查找这个时刻“稍微靠前”的位点作为同步位点，然后再通过判断跳过那些在从库B上已经执行过的事务。

```text
mysqlbinlog File --stop-datetime=T --start-datetime=T // 根据时间查看binlog日志，通过日志定位同步点
```

在从库B上执行过程中，可能会执行已经执行过多的事务，提示主键冲突或其他错误，可以先主动跳过这些错误。跳过错误的方式：
* 一种做法是，主动跳过一个事务。跳过命令的写法是：
    ```sql
    set global sql_slave_skip_counter=1;
    start slave;
    ```
    因为切换过程中，可能会不止重复执行一个事务，所以我们需要在从库 B 刚开始接到新主库 A’时，持续观察，每次碰到这些错误就停下来，执行一次跳过命令，直到不再出现停下来的情况，以此来跳过可能涉及的所有事务。
* 另外一种方式是，通过设置 slave_skip_errors 参数，直接设置跳过指定的错误。
    在执行主备切换时，有这么两类错误，是经常会遇到的：1062 错误是插入数据时唯一键冲突；1032 错误是删除数据时找不到行。可以把 slave_skip_errors 设置为 “1032,1062”。
    但是，需要注意的是这个跳过错误的方式只能在主备切换时，并且清楚知道这样跳过错误是无损的，完成主备切换后需要及时设置回来。

### GTID

通过上面方式建立新的主从复制操作都很复杂，MySQL5.6引入了GTID解决这个困难。

GTID 的全称是 Global Transaction Identifier，也就是全局事务 ID，是一个事务在提交的时候生成的，是这个事务的唯一标识。它由两部分组成，格式是：

```text
GTID=server_uuid:gno
```

* server_uuid 是一个实例第一次启动时自动生成的，是一个全局唯一的值；
* gno 是一个整数，初始值是 1，每次提交事务的时候分配给这个事务，并加 1。

MySQL官方文档的GTID定义为：GTID=source_id:transaction_id；这个 transaction_id容易造成误导，并不是事务id，因为事务id在开始事务的时候就分配好的，这个transaction_id只有在提交事务的时候才会分配。

* 启动GTID模式
    在启动MySQL实例的时候，加上参数`gtid_mode=on`和`enforce_gtid_consistency=on`
* GTID的生成方式取决于session 变量`gtid_next`的值
    * 值为`automatic`，代表使用默认值。这时，MySQL 就会把 server_uuid:gno 分配给这个事务。
a. 记录 binlog 的时候，先记录一行 SET @@SESSION.GTID_NEXT=‘server_uuid:gno’;
b. 把这个 GTID 加入本实例的 GTID 集合。

    * 如果 gtid_next 是一个指定的 GTID 的值，比如通过 set gtid_next='current_gtid’指定为 current_gtid，那么就有两种可能：
a. 如果 current_gtid 已经存在于实例的 GTID 集合中，接下来执行的这个事务会直接被系统忽略；
b. 如果 current_gtid 没有存在于实例的 GTID 集合中，就将这个 current_gtid 分配给接下来要执行的事务，也就是说系统不需要给这个事务生成新的 GTID，因此 gno 也不用加 1。

注意，一个 gtid 只能给一个事务使用。这个事务提交后，如果要执行下一个事务，就要执行 set 命令，把 gtid_next 设置成另外一个 gtid 或者 automatic。

### 基于 GTID 的主备切换

在 GTID 模式下，备库 B 要设置为新主库 A’的从库的语法如下：

```text
CHANGE MASTER TO 
MASTER_HOST=$host_name 
MASTER_PORT=$port 
MASTER_USER=$user_name 
MASTER_PASSWORD=$password 
master_auto_position=1 
```

* master_auto_position=1 就表示这个主备关系使用的是 GTID 协议。

使用GTID主备切换逻辑如下：

* 实例 A’的 GTID 集合记为 set_a，实例 B 的 GTID 集合记为 set_b
* 实例 B 指定主库 A’，基于主备协议建立连接。
* 例 B 把 set_b 发给主库 A’。
* 实例 A’算出 set_a 与 set_b 的差集，也就是所有存在于 set_a，但是不存在于 set_b 的 GTID 的集合，判断 A’本地是否包含了这个差集需要的所有 binlog 事务。
a. 如果不包含，表示 A’已经把实例 B 需要的 binlog 给删掉了，直接返回错误；
b. 如果确认全部包含，A’从自己的 binlog 文件里面，找出第一个不在 set_b 的事务，发给 B；
* 之后就从这个事务开始，往后读文件，按顺序取 binlog 发给 B 去执行。

### GTID 和在线 DDL

在双M结构下，由于索引缺失引起的性能问题，可以在备库上执行DDL语句，备库执行的 DDL 语句也会传给主库，为了避免传回后对主库造成影响，要通过 set sql_log_bin=off 关掉 binlog。

如果双M都打开了GTID模式，也可以通过GTID解决，流程为:

* 在实例 X 上执行 stop slave。
* 在实例 Y 上执行 DDL 语句。注意，这里并不需要关闭 binlog。
* 执行完成后，查出这个 DDL 语句对应的 GTID，并记为 server_uuid_of_Y:gno。
* 到实例 X 上执行以下语句序列：
    ```sql
    set GTID_NEXT="server_uuid_of_Y:gno";
    begin;
    commit;
    set gtid_next=automatic;
    start slave;
    ```
这样做的目的在于，既可以让实例 Y 的更新有 binlog 记录，同时也可以确保不会在实例 X 上执行这条更新。

## 读写分离

读写分离主要目标是分摊主库的压力，常见的基本架构是一主多从。客户端连接方式分为两种：
* 一种是客户端直连主动做负载均衡，这种方式会将数据库的连接信息放在客户端的连接层，由客户端来选择后端数据库进行查询。
* 另一种是客户端和MySQL之间有一个中间代理层proxy，客户端只连接proxy，由proxy根据请求类型和上下文决定请求的分发路由。

**两种方式的特点：**

* 客户端直连方案，因为少了一层 proxy 转发，所以查询性能稍微好一点儿，并且整体架构简单，排查问题更方便。但是在出现主备切换、库迁移等操作的时候，客户端都会感知到，并且需要调整数据库连接信息。可以使用同一配置管理中心，比如zookeeper
* 带 proxy 的架构，对客户端比较友好。客户端不需要关注后端细节，连接维护、后端信息维护等工作，都是由 proxy 完成的。proxy 也需要有高可用架构。因此，带 proxy 架构的整体就相对比较复杂。

目前趋势是往带 proxy 的架构方向发展。

### 过期读问题

由于主从延迟不能百分之百避免，就会导致在从库查询的数据可能不是主库上最新的吗，“在从库上会读到系统的一个过期状态”的现象称之为“过期读”。

**过期读问题的解决方案：**

* 强制走主库方案；
* sleep方案；
* 判断主备无延迟方案；
* 配合semi-sync方案；
* 等主库位点方案；
* 等GTID方案。

**强制走主库方案**

强制走主库方案其实就是，将查询请求做分类。

1.对于必须要拿到最新结果的请求，强制将其发到主库上。比如，在一个交易平台上，卖家发布商品以后，马上要返回主页面，看商品是否发布成功。那么，这个请求需要拿到最新的结果，就必须走主库。

2.对于可以读到旧数据的请求，才将其发到从库上。在这个交易平台上，买家来逛商铺页面，就算晚几秒看到最新发布的商品，也是可以接受的。那么，这类请求就可以走从库。

最大的问题是所有查询都不能是过期读的需求。

**sleep方案**

比较鸡肋的方案，主库更新后，读从库之前需要先sleep一下。但是sleep后也可能查询的是过期数据，无法准确指定主备延迟的时间时多少，适用于主备延迟很短，在1秒以内的情况。

**判断主备无延迟方案**

要确保备库无延迟，通常有三种做法。

第一种确保主备无延迟的方法是，每次从库执行查询请求前，先判断 seconds_behind_master 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求。

第二种方法，对比位点确保主备无延迟，命令`show slave status`:

* Master_Log_File 和 Read_Master_Log_Pos，表示的是读到的主库的最新位点；
* Relay_Master_Log_File 和 Exec_Master_Log_Pos，表示的是备库执行的最新位点。

如果 Master_Log_File 和 Relay_Master_Log_File、Read_Master_Log_Pos 和 Exec_Master_Log_Pos 这两组值完全相同，就表示接收到的日志已经同步完成。

第三种方法，对比 GTID 集合确保主备无延迟：
* Auto_Position=1 ，表示这对主备关系使用了 GTID 协议。
* Retrieved_Gtid_Set，是备库收到的所有日志的 GTID 集合；
* Executed_Gtid_Set，是备库所有已经执行完成的 GTID 集合。

如果这两个集合相同，也表示备库接收到的日志都已经同步完成。

对比位点和对比 GTID 这两种方法，都要比判断 seconds_behind_master 是否为 0 更准确。但是并不是最准确的方法，可能出现主库执行完成后binlog还没有发送到从库的情况，也会出现过期查。

**配合 semi-sync方案**

半同步复制，也就是 semi-sync replication。

semi-sync 做了这样的设计：
1.事务提交的时候，主库把 binlog 发给从库；
2.从库收到 binlog 以后，发回给主库一个 ack，表示收到了；
3.主库收到这个 ack 以后，才能给客户端返回“事务完成”的确认。

这样，semi-sync 配合前面关于位点的判断，就能够确定在从库上执行的查询请求，可以避免过期读。但是，semi-sync+ 位点判断的方案，只对一主一备的场景是成立的。在一主多从场景中，主库只要等到一个从库的 ack，就开始给客户端返回确认。这时，在从库上执行查询请求，就有两种情况：
1.如果查询是落在这个响应了 ack 的从库上，是能够确保读到最新数据；
2.但如果是查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题。

**判断同步位点的方案还有另外一个潜在的问题**，即：如果在业务更新的高峰期，主库的位点或者 GTID 集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况。

semi-sync 配合判断主备无延迟的方案，存在两个问题：
1.一主多从的时候，在某些从库执行查询请求会存在过期读的现象；
2.在持续延迟的情况下，可能出现过度等待的问题。

**实际上，不一定要等到主库没有延迟再去查询数据，只要保证要查询的数据的事务tx1在备库上已经执行完成就可以了**

**等主库位点方案**

```sql
select master_pos_wait(file, pos[, timeout]);
```

上面命令的逻辑是：
1.在从库执行；
2.参数file和pos指的是主库上的文件名和位置；
3.timeout 可选，设置为正整数 N 表示这个函数最多等待 N 秒。

这个命令正常返回的结果是一个正整数 M，表示从命令开始执行，到应用完 file 和 pos 表示的 binlog 位置，执行了多少事务。除了正常返回一个正整数 M 外，这条命令还会返回一些其他结果，包括：
1.如果执行期间，备库同步线程发生异常，则返回 NULL；
2.如果等待超过 N 秒，就返回 -1；
3.如果刚开始执行的时候，就发现已经执行过这个位置了，则返回 0。

对于主库上的事务trx1，再执行一个查询请求防止过期读的请求逻辑是：
1.trx1 事务更新完成后，马上执行 show master status 得到当前主库执行到的 File 和 Position；
2.选定一个从库执行查询语句；
3.在从库上执行 select master_pos_wait(File, Position, 1)；
4.如果返回值是 >=0 的正整数，则在这个从库执行查询语句；
5.否则，到主库执行查询语句或者放弃查询，这个取决于业务逻辑进行选择。

**GTID 方案**

这个方案与等主库位点方案类似。前提是开启了GTID模式。

```sql
select wait_for_executed_gtid_set(gtid_set, 1);
```

上面命令的逻辑是：
1.在从库上执行；
2.等待，直到这个库执行的事务中包含传入的 gtid_set，返回 0；
3.超时返回 1。

在等主库位点的方案中，执行完事务还要去主库执行`show master status`查询位点。MySQL5.7.6版本开始，允许在执行完更新类事务后，把这个事务的GTID返回给客户端，这样等GTID方案就可以减少一次查询。

等 GTID 的执行流程：
1.trx1 事务更新完成后，从返回包直接获取这个事务的 GTID，记为 gtid1；
2.选定一个从库执行查询语句；
3.在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)；
4.如果返回值是 0，则在这个从库执行查询语句；
5.否则，到主库执行查询语句或者放弃查询，这个取决于业务逻辑进行选择。

**怎么能够让 MySQL 在执行事务后，返回包中带上 GTID 呢？**

需要将参数 session_track_gtids 设置为 OWN_GTID，然后通过 API 接口 mysql_session_track_get_first 从返回包解析出 GTID 的值即可。