# MySQL Memory引擎

## 内存表的数据组织结构

Memory 引擎的数据和索引是分开的。

![Memory引擎数据组织](../../../../youdaonote-images/7EA1E053D7984E2A9984E60480688265.jpeg)

内存表的数据部分以数组的方式单独存放，而主键索引里存放的是每个数据的位置。主键 id 是 hash 索引，可以看到索引上的 key 并不是有序的。

在内存表 t1 中，当执行 select * 的时候，走的是全表扫描，也就是顺序扫描这个数组。因此，0 就是最后一个被读到，并放入结果集的数据。

**InnoDB 和 Memory 引擎的数据组织方式是不同的：**

* InnoDB 引擎把数据放在主键索引上，其他索引上保存的是主键 id。这种方式，称为索引组织表（Index Organizied Table）。
* Memory 引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，称为堆组织表（Heap Organizied Table）。

**InnoDB和Memory的典型不同之处：**

* InnoDB的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的；
* 当数据文件有空洞的时候，InnoDB表插入新数据的时候，为了保证数据的有序性，只能在固定位置插入新值，而内存表找到空位就可以插入新值；
* 数据位置发生变化的时候，InnoDB只需要修改主键索引，而内存表需要修改所有索引；
* InnoDB 表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的。
* InnoDB 支持变长数据类型，不同记录的长度可能不同；内存表不支持 Blob 和 Text 字段，并且即使定义了 varchar(N)，实际也当作 char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。

## hash 索引和 B-Tree 索引

Memory引擎默认索引方式为hash索引，hash索引不支持范围查找，进行范围查找需要走全表扫描。但是Memory引擎支持B-Tree索引，可以在创建索引的时候指定：

```sql
alter table t1 add index a_btree_index using btree (id);
```

![Memory B-tree索引](../../../../youdaonote-images/5C072C77134E4FE8851BCB63A63D2F94.jpeg)

## 为什么不建议在生产环境上使用内存表

主要原因包含两个方面：锁粒度问题和数据持久化问题

* 内存表的锁

    内存表不支持行锁，只支持表锁。因此，一张表只要有更新，就会堵住其他所有在这个表上的读写操作。

* 数据持久性问题

    数据放在内存中，是内存表的优势，但也是一个劣势。因为，数据库重启的时候，所有的内存表都会被清空。

    在高可用架构下，内存表的这个特点简直可以当做 bug 来看待了。

    * M-S 架构下，使用内存表。如果备库重启，内存表t1的数据会被清空。但是这时候主库发来一个update t1的语句，这时候备库应用线程就会报错“找不到要更新的行”。这样就会导致主备同步停止。
    * 双 M 结构下，使用内存表。
        由于 MySQL 知道重启之后，内存表的数据会丢失。所以，担心主库重启之后，出现主备不一致，MySQL 在实现上做了这样一件事儿：在数据库重启之后，往 binlog 里面写入一行 DELETE FROM t1。所以在备库重启的时候，备库 binlog 里的 delete 语句就会传到主库，然后把主库内存表的内容删除。这样你在使用的时候就会发现，主库的内存表数据突然被清空了。

**什么时候可以使用内存表，什么时候不能使用内存表？**

* 在数据量可控，不会耗费过多内存的情况下，可以考虑使用内存表。
* 如果表的更新量大，那么并发度是一个很重要的参考指标，InnoDB 支持行锁，并发度比内存表好；
* 能放到内存表的数据量都不大。如果你考虑的是读的性能，一个读 QPS 很高并且数据量不大的表，即使是使用 InnoDB，数据也是都会缓存在 InnoDB Buffer Pool 里的。因此，使用 InnoDB 表的读性能也不会差。
* 临时表，可以使用内存表。内存临时表刚好可以无视内存表的两个不足。
    * 临时表不会被其他线程访问，没有并发性的问题；
    * 临时表重启后也是需要删除的，清空数据这个问题不存在；
    * 备库的临时表也不会影响主库的用户线程。